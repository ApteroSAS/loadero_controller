/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Loadero Controller
 * This application serves main Loadero's endpoints that can be used to manipulate test data and other services
 *
 * OpenAPI spec version: v0.32.1
 * Contact: support@loadero.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://api.loadero.com/v2".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration | undefined;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    // @ts-ignore
    name: "RequiredError" | undefined
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AWSInfo
 */
export interface AWSInfo {
    /**
     * 
     * @type {string}
     * @memberof AWSInfo
     */
    accountId: string;
    /**
     * 
     * @type {string}
     * @memberof AWSInfo
     */
    artifactBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof AWSInfo
     */
    clientId: string;
    /**
     * 
     * @type {Date}
     * @memberof AWSInfo
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof AWSInfo
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AWSInfo
     */
    logBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof AWSInfo
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof AWSInfo
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    avatar?: string;
    /**
     * 
     * @type {Date}
     * @memberof Account
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    firstName: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Account
     */
    lastLogin?: Date;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    lastName: string;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    superuser?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof Account
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface AddressInfo
 */
export interface AddressInfo {
    /**
     * 
     * @type {string}
     * @memberof AddressInfo
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressInfo
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressInfo
     */
    line1?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressInfo
     */
    line2?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressInfo
     */
    postalCode?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressInfo
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface ArtifactInfo
 */
export interface ArtifactInfo {
    /**
     * 
     * @type {string}
     * @memberof ArtifactInfo
     */
    error?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ArtifactInfo
     */
    paths?: Array<string>;
}
/**
 * ArtifactsInfo contains all artifact URLs from single result for each corresponding artifact type. If error was present for a artifact type then URL paths for that artifact will be empty.
 * @export
 * @interface ArtifactsInfo
 */
export interface ArtifactsInfo {
    /**
     * 
     * @type {ArtifactInfo}
     * @memberof ArtifactsInfo
     */
    audio?: ArtifactInfo;
    /**
     * 
     * @type {ArtifactInfo}
     * @memberof ArtifactsInfo
     */
    downloads?: ArtifactInfo;
    /**
     * 
     * @type {ArtifactInfo}
     * @memberof ArtifactsInfo
     */
    screenshots?: ArtifactInfo;
    /**
     * 
     * @type {ArtifactInfo}
     * @memberof ArtifactsInfo
     */
    video?: ArtifactInfo;
}
/**
 * 
 * @export
 * @interface Assert
 */
export interface Assert {
    /**
     * 
     * @type {Date}
     * @memberof Assert
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof Assert
     */
    expected: string;
    /**
     * 
     * @type {number}
     * @memberof Assert
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Assert
     */
    operator: string;
    /**
     * 
     * @type {string}
     * @memberof Assert
     */
    path: string;
    /**
     * 
     * @type {number}
     * @memberof Assert
     */
    testId?: number;
    /**
     * 
     * @type {Date}
     * @memberof Assert
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface AssertOverview
 */
export interface AssertOverview {
    /**
     * 
     * @type {string}
     * @memberof AssertOverview
     */
    expected: string;
    /**
     * 
     * @type {number}
     * @memberof AssertOverview
     */
    fail?: number;
    /**
     * 
     * @type {string}
     * @memberof AssertOverview
     */
    operator: string;
    /**
     * 
     * @type {number}
     * @memberof AssertOverview
     */
    pass?: number;
    /**
     * 
     * @type {string}
     * @memberof AssertOverview
     */
    path: string;
    /**
     * 
     * @type {Array<RunAssertPrecondition>}
     * @memberof AssertOverview
     */
    preconditions?: Array<RunAssertPrecondition>;
    /**
     * 
     * @type {number}
     * @memberof AssertOverview
     */
    runAssertId?: number;
    /**
     * 
     * @type {number}
     * @memberof AssertOverview
     */
    skip?: number;
    /**
     * 
     * @type {string}
     * @memberof AssertOverview
     */
    status?: string;
}
/**
 * AssertPrecondition describes single assert precondition instance with JSON field descriptions.
 * @export
 * @interface AssertPrecondition
 */
export interface AssertPrecondition {
    /**
     * 
     * @type {number}
     * @memberof AssertPrecondition
     */
    assertId?: number;
    /**
     * 
     * @type {Date}
     * @memberof AssertPrecondition
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof AssertPrecondition
     */
    expected: string;
    /**
     * 
     * @type {number}
     * @memberof AssertPrecondition
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AssertPrecondition
     */
    operator: string;
    /**
     * 
     * @type {string}
     * @memberof AssertPrecondition
     */
    property: string;
    /**
     * 
     * @type {Date}
     * @memberof AssertPrecondition
     */
    updated?: Date;
}
/**
 * AudioFeed is a concrete classificator value that is used to describe different audio feed values. Audio feed indicates the currently supported audio values.
 * @export
 * @interface AudioFeed
 */
export interface AudioFeed {
    /**
     * 
     * @type {ClassificatorType}
     * @memberof AudioFeed
     */
    classificator?: ClassificatorType;
    /**
     * 
     * @type {string}
     * @memberof AudioFeed
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AudioFeed
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AudioFeed
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AudioFeed
     */
    value?: string;
}
/**
 * AWSInfoReponse is response format that contains linked projects info and AWSInfo corresponding to query.
 * @export
 * @interface AwsInfoReponse
 */
export interface AwsInfoReponse {
    /**
     * 
     * @type {string}
     * @memberof AwsInfoReponse
     */
    accountId: string;
    /**
     * 
     * @type {string}
     * @memberof AwsInfoReponse
     */
    artifactBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof AwsInfoReponse
     */
    clientId: string;
    /**
     * 
     * @type {Date}
     * @memberof AwsInfoReponse
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof AwsInfoReponse
     */
    id?: number;
    /**
     * 
     * @type {Array<SimpleProject>}
     * @memberof AwsInfoReponse
     */
    linkedProjects?: Array<SimpleProject>;
    /**
     * 
     * @type {string}
     * @memberof AwsInfoReponse
     */
    logBucket?: string;
    /**
     * 
     * @type {string}
     * @memberof AwsInfoReponse
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof AwsInfoReponse
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface Base
 */
export interface Base {
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    computeUnit?: string;
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    groupName?: string;
    /**
     * 
     * @type {number}
     * @memberof Base
     */
    groupNum?: number;
    /**
     * 
     * @type {string}
     * @memberof Base
     */
    participantName?: string;
    /**
     * 
     * @type {number}
     * @memberof Base
     */
    participantNum?: number;
    /**
     * 
     * @type {number}
     * @memberof Base
     */
    profileId?: number;
}
/**
 * BaseClassificator is exported wrapper for generic classificator type. This type should be used only to further extend capabilities of a classificator, and not used directly. In those cases prefer to use Classificator interface.
 * @export
 * @interface BaseClassificator
 */
export interface BaseClassificator {
    /**
     * 
     * @type {ClassificatorType}
     * @memberof BaseClassificator
     */
    classificator?: ClassificatorType;
    /**
     * 
     * @type {string}
     * @memberof BaseClassificator
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseClassificator
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseClassificator
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseClassificator
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface BillingInfo
 */
export interface BillingInfo {
    /**
     * 
     * @type {AddressInfo}
     * @memberof BillingInfo
     */
    billingAddress?: AddressInfo;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    buyerKind?: string;
    /**
     * normalize indentation
     * @type {string}
     * @memberof BillingInfo
     */
    defaultPaymentMethod?: string;
    /**
     * normalize indentation
     * @type {Array<BillingInvoice>}
     * @memberof BillingInfo
     */
    invoices?: Array<BillingInvoice>;
    /**
     * 
     * @type {string}
     * @memberof BillingInfo
     */
    name?: string;
    /**
     * 
     * @type {BillingInvoice}
     * @memberof BillingInfo
     */
    nextInvoice?: BillingInvoice;
    /**
     * 
     * @type {Array<PaymentMethod>}
     * @memberof BillingInfo
     */
    paymentMethods?: Array<PaymentMethod>;
    /**
     * 
     * @type {number}
     * @memberof BillingInfo
     */
    subscriptionId?: number;
    /**
     * 
     * @type {VatInfo}
     * @memberof BillingInfo
     */
    vatInfo?: VatInfo;
}
/**
 * 
 * @export
 * @interface BillingInvoice
 */
export interface BillingInvoice {
    /**
     * 
     * @type {number}
     * @memberof BillingInvoice
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof BillingInvoice
     */
    computeUnits?: number;
    /**
     * 
     * @type {string}
     * @memberof BillingInvoice
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingInvoice
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingInvoice
     */
    hostedInvoiceUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof BillingInvoice
     */
    paidAt?: number;
    /**
     * 
     * @type {string}
     * @memberof BillingInvoice
     */
    pdf?: string;
    /**
     * 
     * @type {number}
     * @memberof BillingInvoice
     */
    periodEnd?: number;
    /**
     * 
     * @type {number}
     * @memberof BillingInvoice
     */
    periodStart?: number;
    /**
     * 
     * @type {string}
     * @memberof BillingInvoice
     */
    status?: string;
}
/**
 * Browser is a concrete classificator value that is used to describe different browser values. Browser lists currently supported browser types with currently supported versions.
 * @export
 * @interface Browser
 */
export interface Browser {
    /**
     * 
     * @type {ClassificatorType}
     * @memberof Browser
     */
    classificator?: ClassificatorType;
    /**
     * 
     * @type {string}
     * @memberof Browser
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Browser
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Browser
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Browser
     */
    value?: string;
}
/**
 * nolint:golint,revive
 * @export
 */
export type ClassificatorType = string
/**
 * 
 * @export
 * @interface Common
 */
export interface Common {
    /**
     * 
     * @type {string}
     * @memberof Common
     */
    expected: string;
    /**
     * 
     * @type {string}
     * @memberof Common
     */
    operator: string;
    /**
     * 
     * @type {string}
     * @memberof Common
     */
    path: string;
}
/**
 * ComputeUnit is a concrete classificator value that is used to describe different compute unit values. Compute unit lists currently supported compute unit types used in Loadero tests.
 * @export
 * @interface ComputeUnit
 */
export interface ComputeUnit {
    /**
     * 
     * @type {ClassificatorType}
     * @memberof ComputeUnit
     */
    classificator?: ClassificatorType;
    /**
     * 
     * @type {string}
     * @memberof ComputeUnit
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ComputeUnit
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ComputeUnit
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeUnit
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface ComputeUnitUsage
 */
export interface ComputeUnitUsage {
    /**
     * 
     * @type {number}
     * @memberof ComputeUnitUsage
     */
    included?: number;
    /**
     * 
     * @type {number}
     * @memberof ComputeUnitUsage
     */
    used?: number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * Status code of error
     * @type {number}
     * @memberof ErrorResponse
     */
    code?: number;
    /**
     * Error description
     * @type {string}
     * @memberof ErrorResponse
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface ExtendedResult
 */
export interface ExtendedResult {
    /**
     * 
     * @type {MachineStats}
     * @memberof ExtendedResult
     */
    aggregatedMachineStatistics?: MachineStats;
    /**
     * 
     * @type {ArtifactsInfo}
     * @memberof ExtendedResult
     */
    artifacts?: ArtifactsInfo;
    /**
     * 
     * @type {Array<ResultAssert>}
     * @memberof ExtendedResult
     */
    asserts?: Array<ResultAssert>;
    /**
     * 
     * @type {Date}
     * @memberof ExtendedResult
     */
    created?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ExtendedResult
     */
    end?: Date;
    /**
     * 
     * @type {number}
     * @memberof ExtendedResult
     */
    id?: number;
    /**
     * 
     * @type {ResultLog}
     * @memberof ExtendedResult
     */
    logPaths?: ResultLog;
    /**
     * 
     * @type {Array<ResultResourceUsage>}
     * @memberof ExtendedResult
     */
    machineStats?: Array<ResultResourceUsage>;
    /**
     * 
     * @type {Metrics}
     * @memberof ExtendedResult
     */
    metrics?: Metrics;
    /**
     * 
     * @type {RunParticipant}
     * @memberof ExtendedResult
     */
    participantDetails?: RunParticipant;
    /**
     * 
     * @type {Params}
     * @memberof ExtendedResult
     */
    profileParams?: Params;
    /**
     * 
     * @type {number}
     * @memberof ExtendedResult
     */
    runParticipantId?: number;
    /**
     * 
     * @type {string}
     * @memberof ExtendedResult
     */
    seleniumResult?: string;
    /**
     * 
     * @type {Date}
     * @memberof ExtendedResult
     */
    start?: Date;
    /**
     * 
     * @type {string}
     * @memberof ExtendedResult
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof ExtendedResult
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface Filterer
 */
export interface Filterer {
}
/**
 * 
 * @export
 * @interface FullAssert
 */
export interface FullAssert {
    /**
     * 
     * @type {Date}
     * @memberof FullAssert
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof FullAssert
     */
    expected: string;
    /**
     * 
     * @type {number}
     * @memberof FullAssert
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FullAssert
     */
    operator: string;
    /**
     * 
     * @type {string}
     * @memberof FullAssert
     */
    path: string;
    /**
     * 
     * @type {Array<AssertPrecondition>}
     * @memberof FullAssert
     */
    preconditions?: Array<AssertPrecondition>;
    /**
     * 
     * @type {number}
     * @memberof FullAssert
     */
    testId?: number;
    /**
     * 
     * @type {Date}
     * @memberof FullAssert
     */
    updated?: Date;
}
/**
 * fullProject describes single project instance with JSON field descriptions and additional subscription info.
 * @export
 * @interface FullProject
 */
export interface FullProject {
    /**
     * 
     * @type {string}
     * @memberof FullProject
     */
    accountRole?: string;
    /**
     * 
     * @type {number}
     * @memberof FullProject
     */
    awsInfoId?: number;
    /**
     * 
     * @type {ComputeUnitUsage}
     * @memberof FullProject
     */
    computeUnitUsage?: ComputeUnitUsage;
    /**
     * 
     * @type {Date}
     * @memberof FullProject
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof FullProject
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FullProject
     */
    language: string;
    /**
     * 
     * @type {number}
     * @memberof FullProject
     */
    memberCount?: number;
    /**
     * 
     * @type {string}
     * @memberof FullProject
     */
    name: string;
    /**
     * 
     * @type {Subscription}
     * @memberof FullProject
     */
    subscription?: Subscription;
    /**
     * 
     * @type {number}
     * @memberof FullProject
     */
    subscriptionId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof FullProject
     */
    trialExpired?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof FullProject
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface Generic
 */
export interface Generic {
    /**
     * 
     * @type {Date}
     * @memberof Generic
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof Generic
     */
    id?: number;
    /**
     * 
     * @type {Date}
     * @memberof Generic
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    count: number;
    /**
     * 
     * @type {Date}
     * @memberof Group
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    participantCount?: number;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    testId?: number;
    /**
     * 
     * @type {Date}
     * @memberof Group
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface GroupIDCopyBody
 */
export interface GroupIDCopyBody {
    /**
     * 
     * @type {string}
     * @memberof GroupIDCopyBody
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface GroupParticipantBody
 */
export interface GroupParticipantBody {
    /**
     * 
     * @type {string}
     * @memberof GroupParticipantBody
     */
    audioFeed?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupParticipantBody
     */
    browser: string;
    /**
     * normalize indentaion
     * @type {string}
     * @memberof GroupParticipantBody
     */
    computeUnit?: string;
    /**
     * 
     * @type {number}
     * @memberof GroupParticipantBody
     */
    count: number;
    /**
     * 
     * @type {Date}
     * @memberof GroupParticipantBody
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof GroupParticipantBody
     */
    groupId?: number;
    /**
     * 
     * @type {number}
     * @memberof GroupParticipantBody
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof GroupParticipantBody
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupParticipantBody
     */
    mediaType?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupParticipantBody
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GroupParticipantBody
     */
    network?: string;
    /**
     * 
     * @type {number}
     * @memberof GroupParticipantBody
     */
    profileId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof GroupParticipantBody
     */
    recordAudio?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GroupParticipantBody
     */
    testId?: number;
    /**
     * 
     * @type {Date}
     * @memberof GroupParticipantBody
     */
    updated?: Date;
    /**
     * 
     * @type {string}
     * @memberof GroupParticipantBody
     */
    videoFeed?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Filterer}
     * @memberof InlineResponse200
     */
    filter?: Filterer;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse200
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Run>}
     * @memberof InlineResponse200
     */
    results?: Array<Run>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Filterer}
     * @memberof InlineResponse2001
     */
    filter?: Filterer;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2001
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<RunParticipantBody>}
     * @memberof InlineResponse2001
     */
    results?: Array<RunParticipantBody>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Filterer}
     * @memberof InlineResponse2002
     */
    filter?: Filterer;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2002
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Overview>}
     * @memberof InlineResponse2002
     */
    results?: Array<Overview>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<AssertOverview>}
     * @memberof InlineResponse2003
     */
    asserts?: Array<AssertOverview>;
    /**
     * 
     * @type {MachineStats}
     * @memberof InlineResponse2003
     */
    machineStats?: MachineStats;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Filterer}
     * @memberof InlineResponse2004
     */
    filter?: Filterer;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2004
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Test>}
     * @memberof InlineResponse2004
     */
    results?: Array<Test>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Filterer}
     * @memberof InlineResponse2005
     */
    filter?: Filterer;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2005
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<FullAssert>}
     * @memberof InlineResponse2005
     */
    results?: Array<FullAssert>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {Filterer}
     * @memberof InlineResponse2006
     */
    filter?: Filterer;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2006
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<AssertPrecondition>}
     * @memberof InlineResponse2006
     */
    results?: Array<AssertPrecondition>;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {Filterer}
     * @memberof InlineResponse2007
     */
    filter?: Filterer;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2007
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<Group>}
     * @memberof InlineResponse2007
     */
    results?: Array<Group>;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {Filterer}
     * @memberof InlineResponse2008
     */
    filter?: Filterer;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2008
     */
    pagination?: Pagination;
    /**
     * 
     * @type {Array<ParticipantBody>}
     * @memberof InlineResponse2008
     */
    results?: Array<ParticipantBody>;
}
/**
 * InvitedMember describes single project invited member instance with JSON field descriptions.
 * @export
 * @interface InvitedMember
 */
export interface InvitedMember {
    /**
     * 
     * @type {Date}
     * @memberof InvitedMember
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof InvitedMember
     */
    email: string;
    /**
     * 
     * @type {number}
     * @memberof InvitedMember
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof InvitedMember
     */
    projectId?: number;
    /**
     * 
     * @type {string}
     * @memberof InvitedMember
     */
    role: string;
    /**
     * 
     * @type {Date}
     * @memberof InvitedMember
     */
    updated?: Date;
}
/**
 * Location is a concrete classificator value that is used to describe different location values. Location defines all available AWS regions from which it is possible to launch Loadero tests.
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {ClassificatorType}
     * @memberof Location
     */
    classificator?: ClassificatorType;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Location
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    value?: string;
}
/**
 * MachineStats consists of indicators about resource usage by the test execution.
 * @export
 * @interface MachineStats
 */
export interface MachineStats {
    /**
     * 
     * @type {Statistics}
     * @memberof MachineStats
     */
    avg?: Statistics;
    /**
     * 
     * @type {Statistics}
     * @memberof MachineStats
     */
    max?: Statistics;
    /**
     * 
     * @type {Statistics}
     * @memberof MachineStats
     */
    min?: Statistics;
    /**
     * 
     * @type {Statistics}
     * @memberof MachineStats
     */
    perc25?: Statistics;
    /**
     * 
     * @type {Statistics}
     * @memberof MachineStats
     */
    perc50?: Statistics;
    /**
     * 
     * @type {Statistics}
     * @memberof MachineStats
     */
    perc75?: Statistics;
    /**
     * 
     * @type {Statistics}
     * @memberof MachineStats
     */
    perc95?: Statistics;
    /**
     * 
     * @type {Statistics}
     * @memberof MachineStats
     */
    perc99?: Statistics;
    /**
     * 
     * @type {Statistics}
     * @memberof MachineStats
     */
    relativeStdDev?: Statistics;
    /**
     * 
     * @type {Statistics}
     * @memberof MachineStats
     */
    stdDev?: Statistics;
    /**
     * 
     * @type {Statistics}
     * @memberof MachineStats
     */
    total?: Statistics;
}
/**
 * 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * 
     * @type {number}
     * @memberof Member
     */
    accountId?: number;
    /**
     * 
     * @type {Date}
     * @memberof Member
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof Member
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Member
     */
    projectId?: number;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    role: string;
    /**
     * 
     * @type {Date}
     * @memberof Member
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface MemberInfo
 */
export interface MemberInfo {
    /**
     * 
     * @type {Account}
     * @memberof MemberInfo
     */
    account?: Account;
    /**
     * 
     * @type {number}
     * @memberof MemberInfo
     */
    accountId?: number;
    /**
     * 
     * @type {Date}
     * @memberof MemberInfo
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof MemberInfo
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof MemberInfo
     */
    projectId?: number;
    /**
     * 
     * @type {string}
     * @memberof MemberInfo
     */
    role: string;
    /**
     * 
     * @type {Date}
     * @memberof MemberInfo
     */
    updated?: Date;
}
/**
 * MemberRole is a concrete classificator value that is used to describe different member role values. Member roles are different values that are assigned to each project member. They follow a predefined hierarchy that allows to define permissions to each member in a project.
 * @export
 * @interface MemberRole
 */
export interface MemberRole {
    /**
     * 
     * @type {ClassificatorType}
     * @memberof MemberRole
     */
    classificator?: ClassificatorType;
    /**
     * 
     * @type {string}
     * @memberof MemberRole
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MemberRole
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MemberRole
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof MemberRole
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    average?: number;
    /**
     * 
     * @type {Date}
     * @memberof Metric
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    dataCount?: number;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    maximum?: number;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    metricPath: string;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    minimum?: number;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    perc25th?: number;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    perc50th?: number;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    perc75th?: number;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    perc95th?: number;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    perc99th?: number;
    /**
     * 
     * @type {number}
     * @memberof Metric
     */
    stddev?: number;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface MetricList
 */
export interface MetricList {
}
/**
 * MetricPath defines joint path of different metric keys that lead to specific metric. Single metric path can have multiple children, forming a tree.
 * @export
 * @interface MetricPath
 */
export interface MetricPath {
    /**
     * 
     * @type {boolean}
     * @memberof MetricPath
     */
    _final?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MetricPath
     */
    ID?: number;
    /**
     * 
     * @type {string}
     * @memberof MetricPath
     */
    key?: string;
    /**
     * 
     * @type {number}
     * @memberof MetricPath
     */
    parentID?: number;
}
/**
 * 
 * @export
 * @interface Metrics
 */
export interface Metrics {
    /**
     * 
     * @type {MetricList}
     * @memberof Metrics
     */
    machine?: MetricList;
    /**
     * 
     * @type {MetricList}
     * @memberof Metrics
     */
    webrtc?: MetricList;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    content: string;
    /**
     * 
     * @type {Date}
     * @memberof ModelFile
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    fileType: string;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    projectId?: number;
    /**
     * 
     * @type {Date}
     * @memberof ModelFile
     */
    updated?: Date;
}
/**
 * Network is a concrete classificator value that is used to describe different network setting values. Network describes group of network conditions that simulate various network conditions for a single user and allow client to test app behaviour under changing network.
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * 
     * @type {ClassificatorType}
     * @memberof Network
     */
    classificator?: ClassificatorType;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Network
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface NetworkParams
 */
export interface NetworkParams {
    /**
     * 
     * @type {number}
     * @memberof NetworkParams
     */
    bytes?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkParams
     */
    bytesPerSecond?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkParams
     */
    dropped?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkParams
     */
    droppedPerSecond?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkParams
     */
    errors?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkParams
     */
    errorsPerSecond?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkParams
     */
    packets?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkParams
     */
    packetsPerSecond?: number;
}
/**
 * NetworkStatistics describes inbound/outbound network type statistics data.
 * @export
 * @interface NetworkStatistics
 */
export interface NetworkStatistics {
    /**
     * 
     * @type {number}
     * @memberof NetworkStatistics
     */
    bytes?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkStatistics
     */
    bytesPerSecond?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkStatistics
     */
    dropped?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkStatistics
     */
    droppedPerSecond?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkStatistics
     */
    errors?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkStatistics
     */
    errorsPerSecond?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkStatistics
     */
    packets?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkStatistics
     */
    packetsPerSecond?: number;
}
/**
 * NewPassword holds fields for new account password creation. Model is used for parsing incoming request for new account creation with account password.
 * @export
 * @interface NewPassword
 */
export interface NewPassword {
    /**
     * 
     * @type {string}
     * @memberof NewPassword
     */
    confirmPassword: string;
    /**
     * 
     * @type {string}
     * @memberof NewPassword
     */
    password: string;
}
/**
 * Operator is a concrete classificator value that is used to describe different math operator values. Operator is mainly used in assertions to compare values. This classificator refers to mathematical operators.
 * @export
 * @interface Operator
 */
export interface Operator {
    /**
     * 
     * @type {ClassificatorType}
     * @memberof Operator
     */
    classificator?: ClassificatorType;
    /**
     * 
     * @type {string}
     * @memberof Operator
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Operator
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Operator
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Operator
     */
    value?: string;
}
/**
 * Overview describes single result overview instance with JSON field descriptions.
 * @export
 * @interface Overview
 */
export interface Overview {
    /**
     * 
     * @type {Date}
     * @memberof Overview
     */
    created?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Overview
     */
    end?: Date;
    /**
     * 
     * @type {number}
     * @memberof Overview
     */
    id?: number;
    /**
     * 
     * @type {RunParticipant}
     * @memberof Overview
     */
    participantDetails?: RunParticipant;
    /**
     * 
     * @type {Params}
     * @memberof Overview
     */
    profileParams?: Params;
    /**
     * 
     * @type {number}
     * @memberof Overview
     */
    runParticipantId?: number;
    /**
     * 
     * @type {string}
     * @memberof Overview
     */
    seleniumResult?: string;
    /**
     * 
     * @type {Date}
     * @memberof Overview
     */
    start?: Date;
    /**
     * 
     * @type {string}
     * @memberof Overview
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof Overview
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    limit?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pagination
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface Params
 */
export interface Params {
    /**
     * 
     * @type {string}
     * @memberof Params
     */
    audioFeed?: string;
    /**
     * 
     * @type {string}
     * @memberof Params
     */
    browser: string;
    /**
     * 
     * @type {string}
     * @memberof Params
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof Params
     */
    mediaType?: string;
    /**
     * 
     * @type {string}
     * @memberof Params
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof Params
     */
    videoFeed?: string;
}
/**
 * 
 * @export
 * @interface ParticipantBody
 */
export interface ParticipantBody {
    /**
     * 
     * @type {string}
     * @memberof ParticipantBody
     */
    audioFeed?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipantBody
     */
    browser: string;
    /**
     * normalize indentaion
     * @type {string}
     * @memberof ParticipantBody
     */
    computeUnit?: string;
    /**
     * 
     * @type {number}
     * @memberof ParticipantBody
     */
    count: number;
    /**
     * 
     * @type {Date}
     * @memberof ParticipantBody
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof ParticipantBody
     */
    groupId?: number;
    /**
     * 
     * @type {number}
     * @memberof ParticipantBody
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ParticipantBody
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipantBody
     */
    mediaType?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipantBody
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipantBody
     */
    network?: string;
    /**
     * 
     * @type {number}
     * @memberof ParticipantBody
     */
    profileId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ParticipantBody
     */
    recordAudio?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ParticipantBody
     */
    testId?: number;
    /**
     * 
     * @type {Date}
     * @memberof ParticipantBody
     */
    updated?: Date;
    /**
     * 
     * @type {string}
     * @memberof ParticipantBody
     */
    videoFeed?: string;
}
/**
 * 
 * @export
 * @interface ParticipantIDCopyBody
 */
export interface ParticipantIDCopyBody {
    /**
     * 
     * @type {string}
     * @memberof ParticipantIDCopyBody
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface PaymentMethod
 */
export interface PaymentMethod {
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    brand?: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    cardholderName?: string;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    expMonth?: number;
    /**
     * 
     * @type {number}
     * @memberof PaymentMethod
     */
    expYear?: number;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PaymentMethod
     */
    isDefault?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PaymentMethod
     */
    last4?: string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    accountRole?: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    awsInfoId?: number;
    /**
     * 
     * @type {Date}
     * @memberof Project
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    language: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    memberCount?: number;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Project
     */
    subscriptionId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Project
     */
    trialExpired?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof Project
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface Result
 */
export interface Result {
    /**
     * 
     * @type {Date}
     * @memberof Result
     */
    created?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Result
     */
    end?: Date;
    /**
     * 
     * @type {number}
     * @memberof Result
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Result
     */
    runParticipantId?: number;
    /**
     * 
     * @type {string}
     * @memberof Result
     */
    seleniumResult?: string;
    /**
     * 
     * @type {Date}
     * @memberof Result
     */
    start?: Date;
    /**
     * 
     * @type {string}
     * @memberof Result
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof Result
     */
    updated?: Date;
}
/**
 * ResultAssert describes single result assert instance with JSON field descriptions.
 * @export
 * @interface ResultAssert
 */
export interface ResultAssert {
    /**
     * 
     * @type {string}
     * @memberof ResultAssert
     */
    actual?: string;
    /**
     * 
     * @type {Date}
     * @memberof ResultAssert
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof ResultAssert
     */
    expected: string;
    /**
     * 
     * @type {number}
     * @memberof ResultAssert
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ResultAssert
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ResultAssert
     */
    operator: string;
    /**
     * 
     * @type {string}
     * @memberof ResultAssert
     */
    path: string;
    /**
     * 
     * @type {number}
     * @memberof ResultAssert
     */
    resultId?: number;
    /**
     * 
     * @type {number}
     * @memberof ResultAssert
     */
    runAssertId?: number;
    /**
     * 
     * @type {string}
     * @memberof ResultAssert
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface ResultLog
 */
export interface ResultLog {
    /**
     * 
     * @type {string}
     * @memberof ResultLog
     */
    browser?: string;
    /**
     * 
     * @type {Date}
     * @memberof ResultLog
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof ResultLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ResultLog
     */
    resultId?: number;
    /**
     * 
     * @type {string}
     * @memberof ResultLog
     */
    rru?: string;
    /**
     * 
     * @type {string}
     * @memberof ResultLog
     */
    selenium?: string;
    /**
     * 
     * @type {string}
     * @memberof ResultLog
     */
    webrtc?: string;
}
/**
 * ResultResourceUsage describes single result resource usage instance with JSON field descriptions.
 * @export
 * @interface ResultResourceUsage
 */
export interface ResultResourceUsage {
    /**
     * 
     * @type {number}
     * @memberof ResultResourceUsage
     */
    cpuAvailable?: number;
    /**
     * 
     * @type {number}
     * @memberof ResultResourceUsage
     */
    cpuUsage?: number;
    /**
     * 
     * @type {Date}
     * @memberof ResultResourceUsage
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof ResultResourceUsage
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof ResultResourceUsage
     */
    memoryAvailable?: number;
    /**
     * 
     * @type {number}
     * @memberof ResultResourceUsage
     */
    memoryUsage?: number;
    /**
     * 
     * @type {NetworkParams}
     * @memberof ResultResourceUsage
     */
    networkRx?: NetworkParams;
    /**
     * 
     * @type {NetworkParams}
     * @memberof ResultResourceUsage
     */
    networkTx?: NetworkParams;
    /**
     * 
     * @type {Date}
     * @memberof ResultResourceUsage
     */
    readTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof ResultResourceUsage
     */
    resultId?: number;
}
/**
 * ResultStatus is a concrete classificator value that is used to describe different result status values. Result status indicates the final outcome of a single result instance.
 * @export
 * @interface ResultStatus
 */
export interface ResultStatus {
    /**
     * 
     * @type {ClassificatorType}
     * @memberof ResultStatus
     */
    classificator?: ClassificatorType;
    /**
     * 
     * @type {string}
     * @memberof ResultStatus
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResultStatus
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ResultStatus
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ResultStatus
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface Run
 */
export interface Run {
    /**
     * 
     * @type {Date}
     * @memberof Run
     */
    created?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Run
     */
    executionFinished?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Run
     */
    executionStarted?: Date;
    /**
     * 
     * @type {number}
     * @memberof Run
     */
    groupCount?: number;
    /**
     * 
     * @type {number}
     * @memberof Run
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    incrementStrategy?: string;
    /**
     * 
     * @type {number}
     * @memberof Run
     */
    launchingAccountId?: number;
    /**
     * 
     * @type {number}
     * @memberof Run
     */
    participantTimeout?: number;
    /**
     * 
     * @type {Date}
     * @memberof Run
     */
    processingFinished?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Run
     */
    processingStarted?: Date;
    /**
     * 
     * @type {number}
     * @memberof Run
     */
    scriptFileId?: number;
    /**
     * 
     * @type {number}
     * @memberof Run
     */
    startInterval?: number;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof Run
     */
    successRate?: number;
    /**
     * 
     * @type {number}
     * @memberof Run
     */
    testId?: number;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    testMode?: string;
    /**
     * 
     * @type {string}
     * @memberof Run
     */
    testName?: string;
    /**
     * 
     * @type {Date}
     * @memberof Run
     */
    updated?: Date;
}
/**
 * RunAssertPrecondition describes single run assert precondition instance with JSON field descriptions.
 * @export
 * @interface RunAssertPrecondition
 */
export interface RunAssertPrecondition {
    /**
     * 
     * @type {Date}
     * @memberof RunAssertPrecondition
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof RunAssertPrecondition
     */
    expected: string;
    /**
     * 
     * @type {number}
     * @memberof RunAssertPrecondition
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RunAssertPrecondition
     */
    operator: string;
    /**
     * 
     * @type {string}
     * @memberof RunAssertPrecondition
     */
    property: string;
    /**
     * 
     * @type {number}
     * @memberof RunAssertPrecondition
     */
    runAssertId?: number;
    /**
     * 
     * @type {Date}
     * @memberof RunAssertPrecondition
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface RunBody
 */
export interface RunBody {
    /**
     * 
     * @type {Date}
     * @memberof RunBody
     */
    created?: Date;
    /**
     * 
     * @type {Date}
     * @memberof RunBody
     */
    executionFinished?: Date;
    /**
     * 
     * @type {Date}
     * @memberof RunBody
     */
    executionStarted?: Date;
    /**
     * 
     * @type {number}
     * @memberof RunBody
     */
    groupCount?: number;
    /**
     * 
     * @type {number}
     * @memberof RunBody
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RunBody
     */
    incrementStrategy?: string;
    /**
     * 
     * @type {number}
     * @memberof RunBody
     */
    launchingAccountId?: number;
    /**
     * 
     * @type {number}
     * @memberof RunBody
     */
    participantCount?: number;
    /**
     * 
     * @type {number}
     * @memberof RunBody
     */
    participantTimeout?: number;
    /**
     * 
     * @type {Date}
     * @memberof RunBody
     */
    processingFinished?: Date;
    /**
     * 
     * @type {Date}
     * @memberof RunBody
     */
    processingStarted?: Date;
    /**
     * 
     * @type {number}
     * @memberof RunBody
     */
    scriptFileId?: number;
    /**
     * 
     * @type {number}
     * @memberof RunBody
     */
    startInterval?: number;
    /**
     * 
     * @type {string}
     * @memberof RunBody
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof RunBody
     */
    successRate?: number;
    /**
     * 
     * @type {number}
     * @memberof RunBody
     */
    testId?: number;
    /**
     * 
     * @type {string}
     * @memberof RunBody
     */
    testMode?: string;
    /**
     * 
     * @type {string}
     * @memberof RunBody
     */
    testName?: string;
    /**
     * 
     * @type {Date}
     * @memberof RunBody
     */
    updated?: Date;
}
/**
 * RunParticipant describes single run participant instance with JSON field descriptions. swagger: model
 * @export
 * @interface RunParticipant
 */
export interface RunParticipant {
    /**
     * 
     * @type {string}
     * @memberof RunParticipant
     */
    computeUnit?: string;
    /**
     * 
     * @type {Date}
     * @memberof RunParticipant
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof RunParticipant
     */
    groupName?: string;
    /**
     * 
     * @type {number}
     * @memberof RunParticipant
     */
    groupNum?: number;
    /**
     * 
     * @type {number}
     * @memberof RunParticipant
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RunParticipant
     */
    participantName?: string;
    /**
     * 
     * @type {number}
     * @memberof RunParticipant
     */
    participantNum?: number;
    /**
     * 
     * @type {number}
     * @memberof RunParticipant
     */
    profileId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RunParticipant
     */
    recordAudio?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RunParticipant
     */
    runId?: number;
    /**
     * 
     * @type {Date}
     * @memberof RunParticipant
     */
    updated?: Date;
}
/**
 * Body describes single run participant instance with JSON field descriptions.
 * @export
 * @interface RunParticipantBody
 */
export interface RunParticipantBody {
    /**
     * 
     * @type {string}
     * @memberof RunParticipantBody
     */
    audioFeed?: string;
    /**
     * 
     * @type {string}
     * @memberof RunParticipantBody
     */
    browser: string;
    /**
     * 
     * @type {string}
     * @memberof RunParticipantBody
     */
    computeUnit?: string;
    /**
     * 
     * @type {Date}
     * @memberof RunParticipantBody
     */
    created?: Date;
    /**
     * 
     * @type {string}
     * @memberof RunParticipantBody
     */
    groupName?: string;
    /**
     * 
     * @type {number}
     * @memberof RunParticipantBody
     */
    groupNum?: number;
    /**
     * 
     * @type {number}
     * @memberof RunParticipantBody
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RunParticipantBody
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof RunParticipantBody
     */
    mediaType?: string;
    /**
     * 
     * @type {string}
     * @memberof RunParticipantBody
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof RunParticipantBody
     */
    participantName?: string;
    /**
     * 
     * @type {number}
     * @memberof RunParticipantBody
     */
    participantNum?: number;
    /**
     * 
     * @type {number}
     * @memberof RunParticipantBody
     */
    profileId?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RunParticipantBody
     */
    recordAudio?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RunParticipantBody
     */
    runId?: number;
    /**
     * 
     * @type {Date}
     * @memberof RunParticipantBody
     */
    updated?: Date;
    /**
     * 
     * @type {string}
     * @memberof RunParticipantBody
     */
    videoFeed?: string;
}
/**
 * 
 * @export
 * @interface SimpleProject
 */
export interface SimpleProject {
    /**
     * 
     * @type {Date}
     * @memberof SimpleProject
     */
    created?: Date;
    /**
     * 
     * @type {number}
     * @memberof SimpleProject
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SimpleProject
     */
    name?: string;
    /**
     * 
     * @type {Date}
     * @memberof SimpleProject
     */
    updated?: Date;
}
/**
 * Statistics describes result resource usage statistics with JSON field descriptions.
 * @export
 * @interface Statistics
 */
export interface Statistics {
    /**
     * 
     * @type {number}
     * @memberof Statistics
     */
    cpuAvailable?: number;
    /**
     * 
     * @type {number}
     * @memberof Statistics
     */
    cpuUsage?: number;
    /**
     * 
     * @type {number}
     * @memberof Statistics
     */
    memoryAvailable?: number;
    /**
     * 
     * @type {number}
     * @memberof Statistics
     */
    memoryUsage?: number;
    /**
     * 
     * @type {NetworkStatistics}
     * @memberof Statistics
     */
    networkRx?: NetworkStatistics;
    /**
     * 
     * @type {NetworkStatistics}
     * @memberof Statistics
     */
    networkTx?: NetworkStatistics;
}
/**
 * Subscription describes single subscription instance with JSON field descriptions.
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {Date}
     * @memberof Subscription
     */
    activationDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    billingEmail: string;
    /**
     * 
     * @type {Date}
     * @memberof Subscription
     */
    created?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Subscription
     */
    earlySubscriber?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Subscription
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    paymentPlan: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    paymentStatus?: string;
    /**
     * 
     * @type {Date}
     * @memberof Subscription
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface Test
 */
export interface Test {
    /**
     * 
     * @type {Date}
     * @memberof Test
     */
    created?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof Test
     */
    deleted?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Test
     */
    groupCount?: number;
    /**
     * 
     * @type {number}
     * @memberof Test
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Test
     */
    incrementStrategy: string;
    /**
     * 
     * @type {string}
     * @memberof Test
     */
    mode: string;
    /**
     * 
     * @type {string}
     * @memberof Test
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Test
     */
    participantCount?: number;
    /**
     * 
     * @type {number}
     * @memberof Test
     */
    participantTimeout: number;
    /**
     * 
     * @type {number}
     * @memberof Test
     */
    projectId?: number;
    /**
     * 
     * @type {number}
     * @memberof Test
     */
    scriptFileId?: number;
    /**
     * 
     * @type {number}
     * @memberof Test
     */
    startInterval: number;
    /**
     * 
     * @type {Date}
     * @memberof Test
     */
    updated?: Date;
}
/**
 * 
 * @export
 * @interface TestIDCopyBody
 */
export interface TestIDCopyBody {
    /**
     * 
     * @type {string}
     * @memberof TestIDCopyBody
     */
    name?: string;
}
/**
 * TestMode is a concrete classificator value that is used to describe different test mode values. Test mode determines different logical parts of the test such as log collection logic and different service limits.
 * @export
 * @interface TestMode
 */
export interface TestMode {
    /**
     * 
     * @type {ClassificatorType}
     * @memberof TestMode
     */
    classificator?: ClassificatorType;
    /**
     * 
     * @type {string}
     * @memberof TestMode
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TestMode
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TestMode
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof TestMode
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface TokenInfo
 */
export interface TokenInfo {
    /**
     * 
     * @type {string}
     * @memberof TokenInfo
     */
    accessToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenInfo
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenInfo
     */
    clientId?: string;
    /**
     * 
     * @type {number}
     * @memberof TokenInfo
     */
    createdAt?: number;
    /**
     * 
     * @type {number}
     * @memberof TokenInfo
     */
    exp?: number;
    /**
     * 
     * @type {number}
     * @memberof TokenInfo
     */
    expiresIn?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TokenInfo
     */
    scopes?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TokenInfo
     */
    tokenType?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenInfo
     */
    username?: string;
}
/**
 * UpdateUserBody describes the information needed for update account auth request.
 * @export
 * @interface UpdateUserBody
 */
export interface UpdateUserBody {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserBody
     */
    confirmNewPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserBody
     */
    newPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserBody
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserBody
     */
    resetPasswordToken?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserBody
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface ValidationResponse
 */
export interface ValidationResponse {
    /**
     * Status code of error
     * @type {number}
     * @memberof ValidationResponse
     */
    code?: number;
    /**
     * List of validation errors
     * @type {{ [key: string]: Array<string>; }}
     * @memberof ValidationResponse
     */
    errors?: { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface VatInfo
 */
export interface VatInfo {
    /**
     * 
     * @type {string}
     * @memberof VatInfo
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof VatInfo
     */
    value?: string;
}
/**
 * VideoFeed is a concrete classificator value that is used to describe different video feed values. Video feed indicates the currently supported video values.
 * @export
 * @interface VideoFeed
 */
export interface VideoFeed {
    /**
     * 
     * @type {ClassificatorType}
     * @memberof VideoFeed
     */
    classificator?: ClassificatorType;
    /**
     * 
     * @type {string}
     * @memberof VideoFeed
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof VideoFeed
     */
    disabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VideoFeed
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof VideoFeed
     */
    value?: string;
}
/**
 * AssertApi - fetch parameter creator
 * @export
 */
export const AssertApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new assert with given data.
         * @summary Create new assert
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Assert} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssert(projectID: number, testID: number, body?: Assert, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling createAssert.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling createAssert.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/asserts/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Assert" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes assert. Test and assert must be previously created
         * @summary Delete existing assert
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssert(assertID: number, projectID: number, testID: number, options: any = {}): FetchArgs {
            // verify required parameter 'assertID' is not null or undefined
            if (assertID === null || assertID === undefined) {
                throw new RequiredError('assertID','Required parameter assertID was null or undefined when calling deleteAssert.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling deleteAssert.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling deleteAssert.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/asserts/{assertID}/`
                .replace(`{${"assertID"}}`, encodeURIComponent(String(assertID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint duplicates given assert. Test and assert must be previously created.
         * @summary Duplicate existing assert
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateAssert(assertID: number, projectID: number, testID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'assertID' is not null or undefined
            if (assertID === null || assertID === undefined) {
                throw new RequiredError('assertID','Required parameter assertID was null or undefined when calling duplicateAssert.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling duplicateAssert.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling duplicateAssert.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/asserts/{assertID}/copy/`
                .replace(`{${"assertID"}}`, encodeURIComponent(String(assertID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all assert info. Test must be previously created
         * @summary Get all existing asserts for test
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterPath] 
         * @param {string} [filterOperator] 
         * @param {string} [filterExpected] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllAsserts(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterPath?: string, filterOperator?: string, filterExpected?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllAsserts.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readAllAsserts.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/asserts/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterPath !== undefined) {
                localVarQueryParameter['filter_path'] = filterPath;
            }

            if (filterOperator !== undefined) {
                localVarQueryParameter['filter_operator'] = filterOperator;
            }

            if (filterExpected !== undefined) {
                localVarQueryParameter['filter_expected'] = filterExpected;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves assert info. Test and assert must be previously created
         * @summary Read assert info
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAssert(assertID: number, projectID: number, testID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'assertID' is not null or undefined
            if (assertID === null || assertID === undefined) {
                throw new RequiredError('assertID','Required parameter assertID was null or undefined when calling readAssert.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAssert.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readAssert.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/asserts/{assertID}/`
                .replace(`{${"assertID"}}`, encodeURIComponent(String(assertID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates assert with given properties. Test and assert must be previously created
         * @summary Update existing assert
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Assert} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssert(assertID: number, projectID: number, testID: number, body?: Assert, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'assertID' is not null or undefined
            if (assertID === null || assertID === undefined) {
                throw new RequiredError('assertID','Required parameter assertID was null or undefined when calling updateAssert.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling updateAssert.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling updateAssert.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/asserts/{assertID}/`
                .replace(`{${"assertID"}}`, encodeURIComponent(String(assertID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Assert" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssertApi - functional programming interface
 * @export
 */
export const AssertApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new assert with given data.
         * @summary Create new assert
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Assert} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssert(projectID: number, testID: number, body?: Assert, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Assert> {
            const localVarFetchArgs = AssertApiFetchParamCreator(configuration).createAssert(projectID, testID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint deletes assert. Test and assert must be previously created
         * @summary Delete existing assert
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssert(assertID: number, projectID: number, testID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssertApiFetchParamCreator(configuration).deleteAssert(assertID, projectID, testID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint duplicates given assert. Test and assert must be previously created.
         * @summary Duplicate existing assert
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateAssert(assertID: number, projectID: number, testID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Assert> {
            const localVarFetchArgs = AssertApiFetchParamCreator(configuration).duplicateAssert(assertID, projectID, testID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all assert info. Test must be previously created
         * @summary Get all existing asserts for test
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterPath] 
         * @param {string} [filterOperator] 
         * @param {string} [filterExpected] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllAsserts(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterPath?: string, filterOperator?: string, filterExpected?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
            const localVarFetchArgs = AssertApiFetchParamCreator(configuration).readAllAsserts(projectID, testID, limit, offset, describe, filterPath, filterOperator, filterExpected, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves assert info. Test and assert must be previously created
         * @summary Read assert info
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAssert(assertID: number, projectID: number, testID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Assert> {
            const localVarFetchArgs = AssertApiFetchParamCreator(configuration).readAssert(assertID, projectID, testID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint updates assert with given properties. Test and assert must be previously created
         * @summary Update existing assert
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Assert} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssert(assertID: number, projectID: number, testID: number, body?: Assert, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Assert> {
            const localVarFetchArgs = AssertApiFetchParamCreator(configuration).updateAssert(assertID, projectID, testID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssertApi - factory interface
 * @export
 */
export const AssertApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint creates new assert with given data.
         * @summary Create new assert
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Assert} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssert(projectID: number, testID: number, body?: Assert, describe?: string, options?: any) {
            return AssertApiFp(configuration).createAssert(projectID, testID, body, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint deletes assert. Test and assert must be previously created
         * @summary Delete existing assert
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssert(assertID: number, projectID: number, testID: number, options?: any) {
            return AssertApiFp(configuration).deleteAssert(assertID, projectID, testID, options)(fetch, basePath);
        },
        /**
         * This endpoint duplicates given assert. Test and assert must be previously created.
         * @summary Duplicate existing assert
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateAssert(assertID: number, projectID: number, testID: number, describe?: string, options?: any) {
            return AssertApiFp(configuration).duplicateAssert(assertID, projectID, testID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all assert info. Test must be previously created
         * @summary Get all existing asserts for test
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterPath] 
         * @param {string} [filterOperator] 
         * @param {string} [filterExpected] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllAsserts(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterPath?: string, filterOperator?: string, filterExpected?: string, options?: any) {
            return AssertApiFp(configuration).readAllAsserts(projectID, testID, limit, offset, describe, filterPath, filterOperator, filterExpected, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves assert info. Test and assert must be previously created
         * @summary Read assert info
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAssert(assertID: number, projectID: number, testID: number, describe?: string, options?: any) {
            return AssertApiFp(configuration).readAssert(assertID, projectID, testID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint updates assert with given properties. Test and assert must be previously created
         * @summary Update existing assert
         * @param {number} assertID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Assert} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssert(assertID: number, projectID: number, testID: number, body?: Assert, describe?: string, options?: any) {
            return AssertApiFp(configuration).updateAssert(assertID, projectID, testID, body, describe, options)(fetch, basePath);
        },
    };
};

/**
 * AssertApi - object-oriented interface
 * @export
 * @class AssertApi
 * @extends {BaseAPI}
 */
export class AssertApi extends BaseAPI {
    /**
     * This endpoint creates new assert with given data.
     * @summary Create new assert
     * @param {number} projectID 
     * @param {number} testID 
     * @param {Assert} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssertApi
     */
    public createAssert(projectID: number, testID: number, body?: Assert, describe?: string, options?: any) {
        return AssertApiFp(this.configuration).createAssert(projectID, testID, body, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint deletes assert. Test and assert must be previously created
     * @summary Delete existing assert
     * @param {number} assertID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssertApi
     */
    public deleteAssert(assertID: number, projectID: number, testID: number, options?: any) {
        return AssertApiFp(this.configuration).deleteAssert(assertID, projectID, testID, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint duplicates given assert. Test and assert must be previously created.
     * @summary Duplicate existing assert
     * @param {number} assertID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssertApi
     */
    public duplicateAssert(assertID: number, projectID: number, testID: number, describe?: string, options?: any) {
        return AssertApiFp(this.configuration).duplicateAssert(assertID, projectID, testID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all assert info. Test must be previously created
     * @summary Get all existing asserts for test
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterPath] 
     * @param {string} [filterOperator] 
     * @param {string} [filterExpected] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssertApi
     */
    public readAllAsserts(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterPath?: string, filterOperator?: string, filterExpected?: string, options?: any) {
        return AssertApiFp(this.configuration).readAllAsserts(projectID, testID, limit, offset, describe, filterPath, filterOperator, filterExpected, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves assert info. Test and assert must be previously created
     * @summary Read assert info
     * @param {number} assertID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssertApi
     */
    public readAssert(assertID: number, projectID: number, testID: number, describe?: string, options?: any) {
        return AssertApiFp(this.configuration).readAssert(assertID, projectID, testID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint updates assert with given properties. Test and assert must be previously created
     * @summary Update existing assert
     * @param {number} assertID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {Assert} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssertApi
     */
    public updateAssert(assertID: number, projectID: number, testID: number, body?: Assert, describe?: string, options?: any) {
        return AssertApiFp(this.configuration).updateAssert(assertID, projectID, testID, body, describe, options)(this.fetch, this.basePath);
    }

}
/**
 * FileApi - fetch parameter creator
 * @export
 */
export const FileApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves file info.
         * @summary Read file info.
         * @param {number} fileID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFile(fileID: number, projectID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'fileID' is not null or undefined
            if (fileID === null || fileID === undefined) {
                throw new RequiredError('fileID','Required parameter fileID was null or undefined when calling readFile.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readFile.');
            }
            const localVarPath = `/projects/{projectID}/files/{fileID}/`
                .replace(`{${"fileID"}}`, encodeURIComponent(String(fileID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves file info.
         * @summary Read file info.
         * @param {number} fileID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFile(fileID: number, projectID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = FileApiFetchParamCreator(configuration).readFile(fileID, projectID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint retrieves file info.
         * @summary Read file info.
         * @param {number} fileID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readFile(fileID: number, projectID: number, describe?: string, options?: any) {
            return FileApiFp(configuration).readFile(fileID, projectID, describe, options)(fetch, basePath);
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * This endpoint retrieves file info.
     * @summary Read file info.
     * @param {number} fileID 
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public readFile(fileID: number, projectID: number, describe?: string, options?: any) {
        return FileApiFp(this.configuration).readFile(fileID, projectID, describe, options)(this.fetch, this.basePath);
    }

}
/**
 * GroupApi - fetch parameter creator
 * @export
 */
export const GroupApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new group with given data.
         * @summary Create new group
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Group} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(projectID: number, testID: number, body?: Group, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling createGroup.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling createGroup.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Group" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes group. Test and group must be previously created
         * @summary Delete existing group
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupID: number, projectID: number, testID: number, options: any = {}): FetchArgs {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID','Required parameter groupID was null or undefined when calling deleteGroup.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling deleteGroup.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling deleteGroup.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/{groupID}/`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint duplicates given group. If no copy name is provided an \"Copy of\" prefix will be applied to the group name. Test and group must be previously created.
         * @summary Duplicate existing group
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {GroupIDCopyBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateGroup(groupID: number, projectID: number, testID: number, body?: GroupIDCopyBody, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID','Required parameter groupID was null or undefined when calling duplicateGroup.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling duplicateGroup.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling duplicateGroup.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/{groupID}/copy/`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GroupIDCopyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all group info. Test must be previously created
         * @summary Get all existing groups for test
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterName] 
         * @param {string} [filterCountFrom] 
         * @param {string} [filterCountTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllGroups(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllGroups.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readAllGroups.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter_name'] = filterName;
            }

            if (filterCountFrom !== undefined) {
                localVarQueryParameter['filter_count_from'] = filterCountFrom;
            }

            if (filterCountTo !== undefined) {
                localVarQueryParameter['filter_count_to'] = filterCountTo;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves group info. Test and group must be previously created
         * @summary Read group info
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readGroup(groupID: number, projectID: number, testID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID','Required parameter groupID was null or undefined when calling readGroup.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readGroup.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readGroup.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/{groupID}/`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates group with given properties. Test and group must be previously created
         * @summary Update existing group
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Group} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupID: number, projectID: number, testID: number, body?: Group, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID','Required parameter groupID was null or undefined when calling updateGroup.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling updateGroup.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling updateGroup.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/{groupID}/`
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Group" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new group with given data.
         * @summary Create new group
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Group} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(projectID: number, testID: number, body?: Group, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Group> {
            const localVarFetchArgs = GroupApiFetchParamCreator(configuration).createGroup(projectID, testID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint deletes group. Test and group must be previously created
         * @summary Delete existing group
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupID: number, projectID: number, testID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GroupApiFetchParamCreator(configuration).deleteGroup(groupID, projectID, testID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint duplicates given group. If no copy name is provided an \"Copy of\" prefix will be applied to the group name. Test and group must be previously created.
         * @summary Duplicate existing group
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {GroupIDCopyBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateGroup(groupID: number, projectID: number, testID: number, body?: GroupIDCopyBody, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Group> {
            const localVarFetchArgs = GroupApiFetchParamCreator(configuration).duplicateGroup(groupID, projectID, testID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all group info. Test must be previously created
         * @summary Get all existing groups for test
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterName] 
         * @param {string} [filterCountFrom] 
         * @param {string} [filterCountTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllGroups(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
            const localVarFetchArgs = GroupApiFetchParamCreator(configuration).readAllGroups(projectID, testID, limit, offset, describe, filterName, filterCountFrom, filterCountTo, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves group info. Test and group must be previously created
         * @summary Read group info
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readGroup(groupID: number, projectID: number, testID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Group> {
            const localVarFetchArgs = GroupApiFetchParamCreator(configuration).readGroup(groupID, projectID, testID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint updates group with given properties. Test and group must be previously created
         * @summary Update existing group
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Group} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupID: number, projectID: number, testID: number, body?: Group, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Group> {
            const localVarFetchArgs = GroupApiFetchParamCreator(configuration).updateGroup(groupID, projectID, testID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint creates new group with given data.
         * @summary Create new group
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Group} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(projectID: number, testID: number, body?: Group, describe?: string, options?: any) {
            return GroupApiFp(configuration).createGroup(projectID, testID, body, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint deletes group. Test and group must be previously created
         * @summary Delete existing group
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupID: number, projectID: number, testID: number, options?: any) {
            return GroupApiFp(configuration).deleteGroup(groupID, projectID, testID, options)(fetch, basePath);
        },
        /**
         * This endpoint duplicates given group. If no copy name is provided an \"Copy of\" prefix will be applied to the group name. Test and group must be previously created.
         * @summary Duplicate existing group
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {GroupIDCopyBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateGroup(groupID: number, projectID: number, testID: number, body?: GroupIDCopyBody, describe?: string, options?: any) {
            return GroupApiFp(configuration).duplicateGroup(groupID, projectID, testID, body, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all group info. Test must be previously created
         * @summary Get all existing groups for test
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterName] 
         * @param {string} [filterCountFrom] 
         * @param {string} [filterCountTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllGroups(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, options?: any) {
            return GroupApiFp(configuration).readAllGroups(projectID, testID, limit, offset, describe, filterName, filterCountFrom, filterCountTo, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves group info. Test and group must be previously created
         * @summary Read group info
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readGroup(groupID: number, projectID: number, testID: number, describe?: string, options?: any) {
            return GroupApiFp(configuration).readGroup(groupID, projectID, testID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint updates group with given properties. Test and group must be previously created
         * @summary Update existing group
         * @param {number} groupID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {Group} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroup(groupID: number, projectID: number, testID: number, body?: Group, describe?: string, options?: any) {
            return GroupApiFp(configuration).updateGroup(groupID, projectID, testID, body, describe, options)(fetch, basePath);
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * This endpoint creates new group with given data.
     * @summary Create new group
     * @param {number} projectID 
     * @param {number} testID 
     * @param {Group} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public createGroup(projectID: number, testID: number, body?: Group, describe?: string, options?: any) {
        return GroupApiFp(this.configuration).createGroup(projectID, testID, body, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint deletes group. Test and group must be previously created
     * @summary Delete existing group
     * @param {number} groupID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(groupID: number, projectID: number, testID: number, options?: any) {
        return GroupApiFp(this.configuration).deleteGroup(groupID, projectID, testID, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint duplicates given group. If no copy name is provided an \"Copy of\" prefix will be applied to the group name. Test and group must be previously created.
     * @summary Duplicate existing group
     * @param {number} groupID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {GroupIDCopyBody} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public duplicateGroup(groupID: number, projectID: number, testID: number, body?: GroupIDCopyBody, describe?: string, options?: any) {
        return GroupApiFp(this.configuration).duplicateGroup(groupID, projectID, testID, body, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all group info. Test must be previously created
     * @summary Get all existing groups for test
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterName] 
     * @param {string} [filterCountFrom] 
     * @param {string} [filterCountTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public readAllGroups(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, options?: any) {
        return GroupApiFp(this.configuration).readAllGroups(projectID, testID, limit, offset, describe, filterName, filterCountFrom, filterCountTo, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves group info. Test and group must be previously created
     * @summary Read group info
     * @param {number} groupID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public readGroup(groupID: number, projectID: number, testID: number, describe?: string, options?: any) {
        return GroupApiFp(this.configuration).readGroup(groupID, projectID, testID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint updates group with given properties. Test and group must be previously created
     * @summary Update existing group
     * @param {number} groupID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {Group} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public updateGroup(groupID: number, projectID: number, testID: number, body?: Group, describe?: string, options?: any) {
        return GroupApiFp(this.configuration).updateGroup(groupID, projectID, testID, body, describe, options)(this.fetch, this.basePath);
    }

}
/**
 * GroupparticipantsApi - fetch parameter creator
 * @export
 */
export const GroupparticipantsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new group participant with given properties.
         * @summary Create new group participant.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {GroupParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupParticipant(projectID: number, testID: number, groupID: number, body?: GroupParticipantBody, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling createGroupParticipant.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling createGroupParticipant.');
            }
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID','Required parameter groupID was null or undefined when calling createGroupParticipant.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/{groupID}/participants/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GroupParticipantBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes group participant.
         * @summary Delete existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, options: any = {}): FetchArgs {
            // verify required parameter 'participantID' is not null or undefined
            if (participantID === null || participantID === undefined) {
                throw new RequiredError('participantID','Required parameter participantID was null or undefined when calling deleteGroupParticipant.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling deleteGroupParticipant.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling deleteGroupParticipant.');
            }
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID','Required parameter groupID was null or undefined when calling deleteGroupParticipant.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/{groupID}/participants/{participantID}/`
                .replace(`{${"participantID"}}`, encodeURIComponent(String(participantID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint duplicates given group participant. If no copy name is provided an \"Copy of\" prefix will be applied to the participant name.
         * @summary Duplicate existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'participantID' is not null or undefined
            if (participantID === null || participantID === undefined) {
                throw new RequiredError('participantID','Required parameter participantID was null or undefined when calling duplicateGroupParticipant.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling duplicateGroupParticipant.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling duplicateGroupParticipant.');
            }
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID','Required parameter groupID was null or undefined when calling duplicateGroupParticipant.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/{groupID}/participants/{participantID}/copy/`
                .replace(`{${"participantID"}}`, encodeURIComponent(String(participantID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all group participant info.
         * @summary Get all existing group participants for group.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterCountFrom] 
         * @param {string} [filterCountTo] 
         * @param {string} [filterComputeUnit] 
         * @param {string} [filterHasGroup] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllGroupParticipants(projectID: number, testID: number, groupID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, filterComputeUnit?: string, filterHasGroup?: string, filterRecordAudio?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllGroupParticipants.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readAllGroupParticipants.');
            }
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID','Required parameter groupID was null or undefined when calling readAllGroupParticipants.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/{groupID}/participants/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterBrowser !== undefined) {
                localVarQueryParameter['filter_browser'] = filterBrowser;
            }

            if (filterNetwork !== undefined) {
                localVarQueryParameter['filter_network'] = filterNetwork;
            }

            if (filterLocation !== undefined) {
                localVarQueryParameter['filter_location'] = filterLocation;
            }

            if (filterMediaType !== undefined) {
                localVarQueryParameter['filter_media_type'] = filterMediaType;
            }

            if (filterVideoFeed !== undefined) {
                localVarQueryParameter['filter_video_feed'] = filterVideoFeed;
            }

            if (filterAudioFeed !== undefined) {
                localVarQueryParameter['filter_audio_feed'] = filterAudioFeed;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter_name'] = filterName;
            }

            if (filterCountFrom !== undefined) {
                localVarQueryParameter['filter_count_from'] = filterCountFrom;
            }

            if (filterCountTo !== undefined) {
                localVarQueryParameter['filter_count_to'] = filterCountTo;
            }

            if (filterComputeUnit !== undefined) {
                localVarQueryParameter['filter_compute_unit'] = filterComputeUnit;
            }

            if (filterHasGroup !== undefined) {
                localVarQueryParameter['filter_has_group'] = filterHasGroup;
            }

            if (filterRecordAudio !== undefined) {
                localVarQueryParameter['filter_record_audio'] = filterRecordAudio;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves group participant info.
         * @summary Get existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'participantID' is not null or undefined
            if (participantID === null || participantID === undefined) {
                throw new RequiredError('participantID','Required parameter participantID was null or undefined when calling readGroupParticipant.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readGroupParticipant.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readGroupParticipant.');
            }
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID','Required parameter groupID was null or undefined when calling readGroupParticipant.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/{groupID}/participants/{participantID}/`
                .replace(`{${"participantID"}}`, encodeURIComponent(String(participantID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates group participant with given properties.
         * @summary Update existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {GroupParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, body?: GroupParticipantBody, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'participantID' is not null or undefined
            if (participantID === null || participantID === undefined) {
                throw new RequiredError('participantID','Required parameter participantID was null or undefined when calling updateGroupParticipant.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling updateGroupParticipant.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling updateGroupParticipant.');
            }
            // verify required parameter 'groupID' is not null or undefined
            if (groupID === null || groupID === undefined) {
                throw new RequiredError('groupID','Required parameter groupID was null or undefined when calling updateGroupParticipant.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/groups/{groupID}/participants/{participantID}/`
                .replace(`{${"participantID"}}`, encodeURIComponent(String(participantID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"groupID"}}`, encodeURIComponent(String(groupID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GroupParticipantBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupparticipantsApi - functional programming interface
 * @export
 */
export const GroupparticipantsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new group participant with given properties.
         * @summary Create new group participant.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {GroupParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupParticipant(projectID: number, testID: number, groupID: number, body?: GroupParticipantBody, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupParticipantBody> {
            const localVarFetchArgs = GroupparticipantsApiFetchParamCreator(configuration).createGroupParticipant(projectID, testID, groupID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint deletes group participant.
         * @summary Delete existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GroupparticipantsApiFetchParamCreator(configuration).deleteGroupParticipant(participantID, projectID, testID, groupID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint duplicates given group participant. If no copy name is provided an \"Copy of\" prefix will be applied to the participant name.
         * @summary Duplicate existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupParticipantBody> {
            const localVarFetchArgs = GroupparticipantsApiFetchParamCreator(configuration).duplicateGroupParticipant(participantID, projectID, testID, groupID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all group participant info.
         * @summary Get all existing group participants for group.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterCountFrom] 
         * @param {string} [filterCountTo] 
         * @param {string} [filterComputeUnit] 
         * @param {string} [filterHasGroup] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllGroupParticipants(projectID: number, testID: number, groupID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, filterComputeUnit?: string, filterHasGroup?: string, filterRecordAudio?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = GroupparticipantsApiFetchParamCreator(configuration).readAllGroupParticipants(projectID, testID, groupID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterCountFrom, filterCountTo, filterComputeUnit, filterHasGroup, filterRecordAudio, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves group participant info.
         * @summary Get existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupParticipantBody> {
            const localVarFetchArgs = GroupparticipantsApiFetchParamCreator(configuration).readGroupParticipant(participantID, projectID, testID, groupID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint updates group participant with given properties.
         * @summary Update existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {GroupParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, body?: GroupParticipantBody, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupParticipantBody> {
            const localVarFetchArgs = GroupparticipantsApiFetchParamCreator(configuration).updateGroupParticipant(participantID, projectID, testID, groupID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GroupparticipantsApi - factory interface
 * @export
 */
export const GroupparticipantsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint creates new group participant with given properties.
         * @summary Create new group participant.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {GroupParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupParticipant(projectID: number, testID: number, groupID: number, body?: GroupParticipantBody, describe?: string, options?: any) {
            return GroupparticipantsApiFp(configuration).createGroupParticipant(projectID, testID, groupID, body, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint deletes group participant.
         * @summary Delete existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, options?: any) {
            return GroupparticipantsApiFp(configuration).deleteGroupParticipant(participantID, projectID, testID, groupID, options)(fetch, basePath);
        },
        /**
         * This endpoint duplicates given group participant. If no copy name is provided an \"Copy of\" prefix will be applied to the participant name.
         * @summary Duplicate existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, describe?: string, options?: any) {
            return GroupparticipantsApiFp(configuration).duplicateGroupParticipant(participantID, projectID, testID, groupID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all group participant info.
         * @summary Get all existing group participants for group.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterCountFrom] 
         * @param {string} [filterCountTo] 
         * @param {string} [filterComputeUnit] 
         * @param {string} [filterHasGroup] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllGroupParticipants(projectID: number, testID: number, groupID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, filterComputeUnit?: string, filterHasGroup?: string, filterRecordAudio?: string, options?: any) {
            return GroupparticipantsApiFp(configuration).readAllGroupParticipants(projectID, testID, groupID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterCountFrom, filterCountTo, filterComputeUnit, filterHasGroup, filterRecordAudio, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves group participant info.
         * @summary Get existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, describe?: string, options?: any) {
            return GroupparticipantsApiFp(configuration).readGroupParticipant(participantID, projectID, testID, groupID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint updates group participant with given properties.
         * @summary Update existing group participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} groupID 
         * @param {GroupParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, body?: GroupParticipantBody, describe?: string, options?: any) {
            return GroupparticipantsApiFp(configuration).updateGroupParticipant(participantID, projectID, testID, groupID, body, describe, options)(fetch, basePath);
        },
    };
};

/**
 * GroupparticipantsApi - object-oriented interface
 * @export
 * @class GroupparticipantsApi
 * @extends {BaseAPI}
 */
export class GroupparticipantsApi extends BaseAPI {
    /**
     * This endpoint creates new group participant with given properties.
     * @summary Create new group participant.
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} groupID 
     * @param {GroupParticipantBody} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupparticipantsApi
     */
    public createGroupParticipant(projectID: number, testID: number, groupID: number, body?: GroupParticipantBody, describe?: string, options?: any) {
        return GroupparticipantsApiFp(this.configuration).createGroupParticipant(projectID, testID, groupID, body, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint deletes group participant.
     * @summary Delete existing group participant.
     * @param {number} participantID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} groupID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupparticipantsApi
     */
    public deleteGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, options?: any) {
        return GroupparticipantsApiFp(this.configuration).deleteGroupParticipant(participantID, projectID, testID, groupID, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint duplicates given group participant. If no copy name is provided an \"Copy of\" prefix will be applied to the participant name.
     * @summary Duplicate existing group participant.
     * @param {number} participantID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} groupID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupparticipantsApi
     */
    public duplicateGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, describe?: string, options?: any) {
        return GroupparticipantsApiFp(this.configuration).duplicateGroupParticipant(participantID, projectID, testID, groupID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all group participant info.
     * @summary Get all existing group participants for group.
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} groupID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterBrowser] 
     * @param {string} [filterNetwork] 
     * @param {string} [filterLocation] 
     * @param {string} [filterMediaType] 
     * @param {string} [filterVideoFeed] 
     * @param {string} [filterAudioFeed] 
     * @param {string} [filterName] 
     * @param {string} [filterCountFrom] 
     * @param {string} [filterCountTo] 
     * @param {string} [filterComputeUnit] 
     * @param {string} [filterHasGroup] 
     * @param {string} [filterRecordAudio] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupparticipantsApi
     */
    public readAllGroupParticipants(projectID: number, testID: number, groupID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, filterComputeUnit?: string, filterHasGroup?: string, filterRecordAudio?: string, options?: any) {
        return GroupparticipantsApiFp(this.configuration).readAllGroupParticipants(projectID, testID, groupID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterCountFrom, filterCountTo, filterComputeUnit, filterHasGroup, filterRecordAudio, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves group participant info.
     * @summary Get existing group participant.
     * @param {number} participantID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} groupID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupparticipantsApi
     */
    public readGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, describe?: string, options?: any) {
        return GroupparticipantsApiFp(this.configuration).readGroupParticipant(participantID, projectID, testID, groupID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint updates group participant with given properties.
     * @summary Update existing group participant.
     * @param {number} participantID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} groupID 
     * @param {GroupParticipantBody} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupparticipantsApi
     */
    public updateGroupParticipant(participantID: number, projectID: number, testID: number, groupID: number, body?: GroupParticipantBody, describe?: string, options?: any) {
        return GroupparticipantsApiFp(this.configuration).updateGroupParticipant(participantID, projectID, testID, groupID, body, describe, options)(this.fetch, this.basePath);
    }

}
/**
 * ParticipantsApi - fetch parameter creator
 * @export
 */
export const ParticipantsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new participant with given properties.
         * @summary Create new participant.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {ParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParticipant(projectID: number, testID: number, body?: ParticipantBody, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling createParticipant.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling createParticipant.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/participants/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParticipantBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes participant.
         * @summary Delete existing participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParticipant(participantID: number, projectID: number, testID: number, options: any = {}): FetchArgs {
            // verify required parameter 'participantID' is not null or undefined
            if (participantID === null || participantID === undefined) {
                throw new RequiredError('participantID','Required parameter participantID was null or undefined when calling deleteParticipant.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling deleteParticipant.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling deleteParticipant.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/participants/{participantID}/`
                .replace(`{${"participantID"}}`, encodeURIComponent(String(participantID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint duplicates given participant. If no copy name is provided an \"Copy of\" prefix will be applied to the participant name. Group and participant must be previously created.
         * @summary Duplicate existing participant
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {ParticipantIDCopyBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateParticipant(participantID: number, projectID: number, testID: number, body?: ParticipantIDCopyBody, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'participantID' is not null or undefined
            if (participantID === null || participantID === undefined) {
                throw new RequiredError('participantID','Required parameter participantID was null or undefined when calling duplicateParticipant.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling duplicateParticipant.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling duplicateParticipant.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/participants/{participantID}/copy/`
                .replace(`{${"participantID"}}`, encodeURIComponent(String(participantID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParticipantIDCopyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all participant info.
         * @summary Get all existing participants for test.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterCountFrom] 
         * @param {string} [filterCountTo] 
         * @param {string} [filterComputeUnit] 
         * @param {string} [filterHasGroup] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllParticipants(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, filterComputeUnit?: string, filterHasGroup?: string, filterRecordAudio?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllParticipants.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readAllParticipants.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/participants/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterBrowser !== undefined) {
                localVarQueryParameter['filter_browser'] = filterBrowser;
            }

            if (filterNetwork !== undefined) {
                localVarQueryParameter['filter_network'] = filterNetwork;
            }

            if (filterLocation !== undefined) {
                localVarQueryParameter['filter_location'] = filterLocation;
            }

            if (filterMediaType !== undefined) {
                localVarQueryParameter['filter_media_type'] = filterMediaType;
            }

            if (filterVideoFeed !== undefined) {
                localVarQueryParameter['filter_video_feed'] = filterVideoFeed;
            }

            if (filterAudioFeed !== undefined) {
                localVarQueryParameter['filter_audio_feed'] = filterAudioFeed;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter_name'] = filterName;
            }

            if (filterCountFrom !== undefined) {
                localVarQueryParameter['filter_count_from'] = filterCountFrom;
            }

            if (filterCountTo !== undefined) {
                localVarQueryParameter['filter_count_to'] = filterCountTo;
            }

            if (filterComputeUnit !== undefined) {
                localVarQueryParameter['filter_compute_unit'] = filterComputeUnit;
            }

            if (filterHasGroup !== undefined) {
                localVarQueryParameter['filter_has_group'] = filterHasGroup;
            }

            if (filterRecordAudio !== undefined) {
                localVarQueryParameter['filter_record_audio'] = filterRecordAudio;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves participant info.
         * @summary Get existing participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readParticipant(participantID: number, projectID: number, testID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'participantID' is not null or undefined
            if (participantID === null || participantID === undefined) {
                throw new RequiredError('participantID','Required parameter participantID was null or undefined when calling readParticipant.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readParticipant.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readParticipant.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/participants/{participantID}/`
                .replace(`{${"participantID"}}`, encodeURIComponent(String(participantID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates participant with given properties.
         * @summary Update existing participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {ParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParticipant(participantID: number, projectID: number, testID: number, body?: ParticipantBody, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'participantID' is not null or undefined
            if (participantID === null || participantID === undefined) {
                throw new RequiredError('participantID','Required parameter participantID was null or undefined when calling updateParticipant.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling updateParticipant.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling updateParticipant.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/participants/{participantID}/`
                .replace(`{${"participantID"}}`, encodeURIComponent(String(participantID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ParticipantBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ParticipantsApi - functional programming interface
 * @export
 */
export const ParticipantsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new participant with given properties.
         * @summary Create new participant.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {ParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParticipant(projectID: number, testID: number, body?: ParticipantBody, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParticipantBody> {
            const localVarFetchArgs = ParticipantsApiFetchParamCreator(configuration).createParticipant(projectID, testID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint deletes participant.
         * @summary Delete existing participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParticipant(participantID: number, projectID: number, testID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ParticipantsApiFetchParamCreator(configuration).deleteParticipant(participantID, projectID, testID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint duplicates given participant. If no copy name is provided an \"Copy of\" prefix will be applied to the participant name. Group and participant must be previously created.
         * @summary Duplicate existing participant
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {ParticipantIDCopyBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateParticipant(participantID: number, projectID: number, testID: number, body?: ParticipantIDCopyBody, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParticipantBody> {
            const localVarFetchArgs = ParticipantsApiFetchParamCreator(configuration).duplicateParticipant(participantID, projectID, testID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all participant info.
         * @summary Get all existing participants for test.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterCountFrom] 
         * @param {string} [filterCountTo] 
         * @param {string} [filterComputeUnit] 
         * @param {string} [filterHasGroup] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllParticipants(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, filterComputeUnit?: string, filterHasGroup?: string, filterRecordAudio?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
            const localVarFetchArgs = ParticipantsApiFetchParamCreator(configuration).readAllParticipants(projectID, testID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterCountFrom, filterCountTo, filterComputeUnit, filterHasGroup, filterRecordAudio, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves participant info.
         * @summary Get existing participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readParticipant(participantID: number, projectID: number, testID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParticipantBody> {
            const localVarFetchArgs = ParticipantsApiFetchParamCreator(configuration).readParticipant(participantID, projectID, testID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint updates participant with given properties.
         * @summary Update existing participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {ParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParticipant(participantID: number, projectID: number, testID: number, body?: ParticipantBody, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParticipantBody> {
            const localVarFetchArgs = ParticipantsApiFetchParamCreator(configuration).updateParticipant(participantID, projectID, testID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ParticipantsApi - factory interface
 * @export
 */
export const ParticipantsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint creates new participant with given properties.
         * @summary Create new participant.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {ParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createParticipant(projectID: number, testID: number, body?: ParticipantBody, describe?: string, options?: any) {
            return ParticipantsApiFp(configuration).createParticipant(projectID, testID, body, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint deletes participant.
         * @summary Delete existing participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteParticipant(participantID: number, projectID: number, testID: number, options?: any) {
            return ParticipantsApiFp(configuration).deleteParticipant(participantID, projectID, testID, options)(fetch, basePath);
        },
        /**
         * This endpoint duplicates given participant. If no copy name is provided an \"Copy of\" prefix will be applied to the participant name. Group and participant must be previously created.
         * @summary Duplicate existing participant
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {ParticipantIDCopyBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateParticipant(participantID: number, projectID: number, testID: number, body?: ParticipantIDCopyBody, describe?: string, options?: any) {
            return ParticipantsApiFp(configuration).duplicateParticipant(participantID, projectID, testID, body, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all participant info.
         * @summary Get all existing participants for test.
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterCountFrom] 
         * @param {string} [filterCountTo] 
         * @param {string} [filterComputeUnit] 
         * @param {string} [filterHasGroup] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllParticipants(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, filterComputeUnit?: string, filterHasGroup?: string, filterRecordAudio?: string, options?: any) {
            return ParticipantsApiFp(configuration).readAllParticipants(projectID, testID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterCountFrom, filterCountTo, filterComputeUnit, filterHasGroup, filterRecordAudio, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves participant info.
         * @summary Get existing participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readParticipant(participantID: number, projectID: number, testID: number, describe?: string, options?: any) {
            return ParticipantsApiFp(configuration).readParticipant(participantID, projectID, testID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint updates participant with given properties.
         * @summary Update existing participant.
         * @param {number} participantID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {ParticipantBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParticipant(participantID: number, projectID: number, testID: number, body?: ParticipantBody, describe?: string, options?: any) {
            return ParticipantsApiFp(configuration).updateParticipant(participantID, projectID, testID, body, describe, options)(fetch, basePath);
        },
    };
};

/**
 * ParticipantsApi - object-oriented interface
 * @export
 * @class ParticipantsApi
 * @extends {BaseAPI}
 */
export class ParticipantsApi extends BaseAPI {
    /**
     * This endpoint creates new participant with given properties.
     * @summary Create new participant.
     * @param {number} projectID 
     * @param {number} testID 
     * @param {ParticipantBody} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public createParticipant(projectID: number, testID: number, body?: ParticipantBody, describe?: string, options?: any) {
        return ParticipantsApiFp(this.configuration).createParticipant(projectID, testID, body, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint deletes participant.
     * @summary Delete existing participant.
     * @param {number} participantID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public deleteParticipant(participantID: number, projectID: number, testID: number, options?: any) {
        return ParticipantsApiFp(this.configuration).deleteParticipant(participantID, projectID, testID, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint duplicates given participant. If no copy name is provided an \"Copy of\" prefix will be applied to the participant name. Group and participant must be previously created.
     * @summary Duplicate existing participant
     * @param {number} participantID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {ParticipantIDCopyBody} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public duplicateParticipant(participantID: number, projectID: number, testID: number, body?: ParticipantIDCopyBody, describe?: string, options?: any) {
        return ParticipantsApiFp(this.configuration).duplicateParticipant(participantID, projectID, testID, body, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all participant info.
     * @summary Get all existing participants for test.
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterBrowser] 
     * @param {string} [filterNetwork] 
     * @param {string} [filterLocation] 
     * @param {string} [filterMediaType] 
     * @param {string} [filterVideoFeed] 
     * @param {string} [filterAudioFeed] 
     * @param {string} [filterName] 
     * @param {string} [filterCountFrom] 
     * @param {string} [filterCountTo] 
     * @param {string} [filterComputeUnit] 
     * @param {string} [filterHasGroup] 
     * @param {string} [filterRecordAudio] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public readAllParticipants(projectID: number, testID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterCountFrom?: string, filterCountTo?: string, filterComputeUnit?: string, filterHasGroup?: string, filterRecordAudio?: string, options?: any) {
        return ParticipantsApiFp(this.configuration).readAllParticipants(projectID, testID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterCountFrom, filterCountTo, filterComputeUnit, filterHasGroup, filterRecordAudio, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves participant info.
     * @summary Get existing participant.
     * @param {number} participantID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public readParticipant(participantID: number, projectID: number, testID: number, describe?: string, options?: any) {
        return ParticipantsApiFp(this.configuration).readParticipant(participantID, projectID, testID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint updates participant with given properties.
     * @summary Update existing participant.
     * @param {number} participantID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {ParticipantBody} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ParticipantsApi
     */
    public updateParticipant(participantID: number, projectID: number, testID: number, body?: ParticipantBody, describe?: string, options?: any) {
        return ParticipantsApiFp(this.configuration).updateParticipant(participantID, projectID, testID, body, describe, options)(this.fetch, this.basePath);
    }

}
/**
 * PreconditionApi - fetch parameter creator
 * @export
 */
export const PreconditionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new assert precondition with given data.
         * @summary Create new assert precondition
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {AssertPrecondition} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrecondition(projectID: number, testID: number, assertID: number, body?: AssertPrecondition, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling createPrecondition.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling createPrecondition.');
            }
            // verify required parameter 'assertID' is not null or undefined
            if (assertID === null || assertID === undefined) {
                throw new RequiredError('assertID','Required parameter assertID was null or undefined when calling createPrecondition.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/asserts/{assertID}/preconditions/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"assertID"}}`, encodeURIComponent(String(assertID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssertPrecondition" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes assert precondition. Assert and precondition must be previously created
         * @summary Delete existing assert precondition
         * @param {number} preconditionID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, options: any = {}): FetchArgs {
            // verify required parameter 'preconditionID' is not null or undefined
            if (preconditionID === null || preconditionID === undefined) {
                throw new RequiredError('preconditionID','Required parameter preconditionID was null or undefined when calling deletePrecondition.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling deletePrecondition.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling deletePrecondition.');
            }
            // verify required parameter 'assertID' is not null or undefined
            if (assertID === null || assertID === undefined) {
                throw new RequiredError('assertID','Required parameter assertID was null or undefined when calling deletePrecondition.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/asserts/{assertID}/preconditions/{preconditionID}/`
                .replace(`{${"preconditionID"}}`, encodeURIComponent(String(preconditionID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"assertID"}}`, encodeURIComponent(String(assertID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all assert precodndition info. Assert must be previously created
         * @summary Get all existing assert preconditions for assert
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterProperty] 
         * @param {string} [filterOperator] 
         * @param {string} [filterExpected] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllPreconditions(projectID: number, testID: number, assertID: number, limit?: number, offset?: number, describe?: string, filterProperty?: string, filterOperator?: string, filterExpected?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllPreconditions.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readAllPreconditions.');
            }
            // verify required parameter 'assertID' is not null or undefined
            if (assertID === null || assertID === undefined) {
                throw new RequiredError('assertID','Required parameter assertID was null or undefined when calling readAllPreconditions.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/asserts/{assertID}/preconditions/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"assertID"}}`, encodeURIComponent(String(assertID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterProperty !== undefined) {
                localVarQueryParameter['filter_property'] = filterProperty;
            }

            if (filterOperator !== undefined) {
                localVarQueryParameter['filter_operator'] = filterOperator;
            }

            if (filterExpected !== undefined) {
                localVarQueryParameter['filter_expected'] = filterExpected;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves assert precondition info. Assert and precondition must be previously created
         * @summary Read assert precondition info
         * @param {number} preconditionID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'preconditionID' is not null or undefined
            if (preconditionID === null || preconditionID === undefined) {
                throw new RequiredError('preconditionID','Required parameter preconditionID was null or undefined when calling readPrecondition.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readPrecondition.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readPrecondition.');
            }
            // verify required parameter 'assertID' is not null or undefined
            if (assertID === null || assertID === undefined) {
                throw new RequiredError('assertID','Required parameter assertID was null or undefined when calling readPrecondition.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/asserts/{assertID}/preconditions/{preconditionID}/`
                .replace(`{${"preconditionID"}}`, encodeURIComponent(String(preconditionID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"assertID"}}`, encodeURIComponent(String(assertID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates assert precondition with given properties. Assert and precondition must be previously created
         * @summary Update existing assert precondition
         * @param {number} preconditionID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {AssertPrecondition} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, body?: AssertPrecondition, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'preconditionID' is not null or undefined
            if (preconditionID === null || preconditionID === undefined) {
                throw new RequiredError('preconditionID','Required parameter preconditionID was null or undefined when calling updatePrecondition.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling updatePrecondition.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling updatePrecondition.');
            }
            // verify required parameter 'assertID' is not null or undefined
            if (assertID === null || assertID === undefined) {
                throw new RequiredError('assertID','Required parameter assertID was null or undefined when calling updatePrecondition.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/asserts/{assertID}/preconditions/{preconditionID}/`
                .replace(`{${"preconditionID"}}`, encodeURIComponent(String(preconditionID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"assertID"}}`, encodeURIComponent(String(assertID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AssertPrecondition" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PreconditionApi - functional programming interface
 * @export
 */
export const PreconditionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new assert precondition with given data.
         * @summary Create new assert precondition
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {AssertPrecondition} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrecondition(projectID: number, testID: number, assertID: number, body?: AssertPrecondition, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssertPrecondition> {
            const localVarFetchArgs = PreconditionApiFetchParamCreator(configuration).createPrecondition(projectID, testID, assertID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint deletes assert precondition. Assert and precondition must be previously created
         * @summary Delete existing assert precondition
         * @param {number} preconditionID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PreconditionApiFetchParamCreator(configuration).deletePrecondition(preconditionID, projectID, testID, assertID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all assert precodndition info. Assert must be previously created
         * @summary Get all existing assert preconditions for assert
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterProperty] 
         * @param {string} [filterOperator] 
         * @param {string} [filterExpected] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllPreconditions(projectID: number, testID: number, assertID: number, limit?: number, offset?: number, describe?: string, filterProperty?: string, filterOperator?: string, filterExpected?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
            const localVarFetchArgs = PreconditionApiFetchParamCreator(configuration).readAllPreconditions(projectID, testID, assertID, limit, offset, describe, filterProperty, filterOperator, filterExpected, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves assert precondition info. Assert and precondition must be previously created
         * @summary Read assert precondition info
         * @param {number} preconditionID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssertPrecondition> {
            const localVarFetchArgs = PreconditionApiFetchParamCreator(configuration).readPrecondition(preconditionID, projectID, testID, assertID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint updates assert precondition with given properties. Assert and precondition must be previously created
         * @summary Update existing assert precondition
         * @param {number} preconditionID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {AssertPrecondition} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, body?: AssertPrecondition, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AssertPrecondition> {
            const localVarFetchArgs = PreconditionApiFetchParamCreator(configuration).updatePrecondition(preconditionID, projectID, testID, assertID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PreconditionApi - factory interface
 * @export
 */
export const PreconditionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint creates new assert precondition with given data.
         * @summary Create new assert precondition
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {AssertPrecondition} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPrecondition(projectID: number, testID: number, assertID: number, body?: AssertPrecondition, describe?: string, options?: any) {
            return PreconditionApiFp(configuration).createPrecondition(projectID, testID, assertID, body, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint deletes assert precondition. Assert and precondition must be previously created
         * @summary Delete existing assert precondition
         * @param {number} preconditionID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, options?: any) {
            return PreconditionApiFp(configuration).deletePrecondition(preconditionID, projectID, testID, assertID, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all assert precodndition info. Assert must be previously created
         * @summary Get all existing assert preconditions for assert
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterProperty] 
         * @param {string} [filterOperator] 
         * @param {string} [filterExpected] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllPreconditions(projectID: number, testID: number, assertID: number, limit?: number, offset?: number, describe?: string, filterProperty?: string, filterOperator?: string, filterExpected?: string, options?: any) {
            return PreconditionApiFp(configuration).readAllPreconditions(projectID, testID, assertID, limit, offset, describe, filterProperty, filterOperator, filterExpected, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves assert precondition info. Assert and precondition must be previously created
         * @summary Read assert precondition info
         * @param {number} preconditionID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readPrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, describe?: string, options?: any) {
            return PreconditionApiFp(configuration).readPrecondition(preconditionID, projectID, testID, assertID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint updates assert precondition with given properties. Assert and precondition must be previously created
         * @summary Update existing assert precondition
         * @param {number} preconditionID 
         * @param {number} projectID 
         * @param {number} testID 
         * @param {number} assertID 
         * @param {AssertPrecondition} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, body?: AssertPrecondition, describe?: string, options?: any) {
            return PreconditionApiFp(configuration).updatePrecondition(preconditionID, projectID, testID, assertID, body, describe, options)(fetch, basePath);
        },
    };
};

/**
 * PreconditionApi - object-oriented interface
 * @export
 * @class PreconditionApi
 * @extends {BaseAPI}
 */
export class PreconditionApi extends BaseAPI {
    /**
     * This endpoint creates new assert precondition with given data.
     * @summary Create new assert precondition
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} assertID 
     * @param {AssertPrecondition} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreconditionApi
     */
    public createPrecondition(projectID: number, testID: number, assertID: number, body?: AssertPrecondition, describe?: string, options?: any) {
        return PreconditionApiFp(this.configuration).createPrecondition(projectID, testID, assertID, body, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint deletes assert precondition. Assert and precondition must be previously created
     * @summary Delete existing assert precondition
     * @param {number} preconditionID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} assertID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreconditionApi
     */
    public deletePrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, options?: any) {
        return PreconditionApiFp(this.configuration).deletePrecondition(preconditionID, projectID, testID, assertID, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all assert precodndition info. Assert must be previously created
     * @summary Get all existing assert preconditions for assert
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} assertID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterProperty] 
     * @param {string} [filterOperator] 
     * @param {string} [filterExpected] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreconditionApi
     */
    public readAllPreconditions(projectID: number, testID: number, assertID: number, limit?: number, offset?: number, describe?: string, filterProperty?: string, filterOperator?: string, filterExpected?: string, options?: any) {
        return PreconditionApiFp(this.configuration).readAllPreconditions(projectID, testID, assertID, limit, offset, describe, filterProperty, filterOperator, filterExpected, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves assert precondition info. Assert and precondition must be previously created
     * @summary Read assert precondition info
     * @param {number} preconditionID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} assertID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreconditionApi
     */
    public readPrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, describe?: string, options?: any) {
        return PreconditionApiFp(this.configuration).readPrecondition(preconditionID, projectID, testID, assertID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint updates assert precondition with given properties. Assert and precondition must be previously created
     * @summary Update existing assert precondition
     * @param {number} preconditionID 
     * @param {number} projectID 
     * @param {number} testID 
     * @param {number} assertID 
     * @param {AssertPrecondition} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreconditionApi
     */
    public updatePrecondition(preconditionID: number, projectID: number, testID: number, assertID: number, body?: AssertPrecondition, describe?: string, options?: any) {
        return PreconditionApiFp(this.configuration).updatePrecondition(preconditionID, projectID, testID, assertID, body, describe, options)(this.fetch, this.basePath);
    }

}
/**
 * ProjectApi - fetch parameter creator
 * @export
 */
export const ProjectApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves project info. Project must be previously created
         * @summary Get existing project
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProject(projectID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readProject.');
            }
            const localVarPath = `/projects/{projectID}/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves project info. Project must be previously created
         * @summary Get existing project
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProject(projectID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FullProject> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).readProject(projectID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint retrieves project info. Project must be previously created
         * @summary Get existing project
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProject(projectID: number, describe?: string, options?: any) {
            return ProjectApiFp(configuration).readProject(projectID, describe, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * This endpoint retrieves project info. Project must be previously created
     * @summary Get existing project
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public readProject(projectID: number, describe?: string, options?: any) {
        return ProjectApiFp(this.configuration).readProject(projectID, describe, options)(this.fetch, this.basePath);
    }

}
/**
 * ProjectresultApi - fetch parameter creator
 * @export
 */
export const ProjectresultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all project run results. Project, run must be previously created and run has to be finished in order to get results
         * @summary Read all project run results
         * @param {number} runID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {string} [filterStartFrom] 
         * @param {string} [filterStartTo] 
         * @param {string} [filterEndFrom] 
         * @param {string} [filterEndTo] 
         * @param {string} [filterStatus] 
         * @param {string} [filterSeleniumResult] 
         * @param {string} [filterDone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllProjectResults(runID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, filterStartFrom?: string, filterStartTo?: string, filterEndFrom?: string, filterEndTo?: string, filterStatus?: string, filterSeleniumResult?: string, filterDone?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readAllProjectResults.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllProjectResults.');
            }
            const localVarPath = `/projects/{projectID}/runs/{runID}/results/`
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterBrowser !== undefined) {
                localVarQueryParameter['filter_browser'] = filterBrowser;
            }

            if (filterNetwork !== undefined) {
                localVarQueryParameter['filter_network'] = filterNetwork;
            }

            if (filterLocation !== undefined) {
                localVarQueryParameter['filter_location'] = filterLocation;
            }

            if (filterMediaType !== undefined) {
                localVarQueryParameter['filter_media_type'] = filterMediaType;
            }

            if (filterVideoFeed !== undefined) {
                localVarQueryParameter['filter_video_feed'] = filterVideoFeed;
            }

            if (filterAudioFeed !== undefined) {
                localVarQueryParameter['filter_audio_feed'] = filterAudioFeed;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter_name'] = filterName;
            }

            if (filterNumFrom !== undefined) {
                localVarQueryParameter['filter_num_from'] = filterNumFrom;
            }

            if (filterNumTo !== undefined) {
                localVarQueryParameter['filter_num_to'] = filterNumTo;
            }

            if (filterGroupName !== undefined) {
                localVarQueryParameter['filter_group_name'] = filterGroupName;
            }

            if (filterGroupNumFrom !== undefined) {
                localVarQueryParameter['filter_group_num_from'] = filterGroupNumFrom;
            }

            if (filterGroupNumTo !== undefined) {
                localVarQueryParameter['filter_group_num_to'] = filterGroupNumTo;
            }

            if (filterRecordAudio !== undefined) {
                localVarQueryParameter['filter_record_audio'] = filterRecordAudio;
            }

            if (filterStartFrom !== undefined) {
                localVarQueryParameter['filter_start_from'] = filterStartFrom;
            }

            if (filterStartTo !== undefined) {
                localVarQueryParameter['filter_start_to'] = filterStartTo;
            }

            if (filterEndFrom !== undefined) {
                localVarQueryParameter['filter_end_from'] = filterEndFrom;
            }

            if (filterEndTo !== undefined) {
                localVarQueryParameter['filter_end_to'] = filterEndTo;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter_status'] = filterStatus;
            }

            if (filterSeleniumResult !== undefined) {
                localVarQueryParameter['filter_selenium_result'] = filterSeleniumResult;
            }

            if (filterDone !== undefined) {
                localVarQueryParameter['filter_done'] = filterDone;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves single project run result info. Project, run and result must be previously created
         * @summary Read single project run result
         * @param {number} resultID 
         * @param {number} runID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectResult(resultID: number, runID: number, projectID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'resultID' is not null or undefined
            if (resultID === null || resultID === undefined) {
                throw new RequiredError('resultID','Required parameter resultID was null or undefined when calling readProjectResult.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readProjectResult.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readProjectResult.');
            }
            const localVarPath = `/projects/{projectID}/runs/{runID}/results/{resultID}/`
                .replace(`{${"resultID"}}`, encodeURIComponent(String(resultID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all project result statisctics. Project and run must be previously created
         * @summary Read all project result statistics
         * @param {number} runID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectResultStatistics(runID: number, projectID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readProjectResultStatistics.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readProjectResultStatistics.');
            }
            const localVarPath = `/projects/{projectID}/runs/{runID}/results/statistics/`
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectresultApi - functional programming interface
 * @export
 */
export const ProjectresultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all project run results. Project, run must be previously created and run has to be finished in order to get results
         * @summary Read all project run results
         * @param {number} runID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {string} [filterStartFrom] 
         * @param {string} [filterStartTo] 
         * @param {string} [filterEndFrom] 
         * @param {string} [filterEndTo] 
         * @param {string} [filterStatus] 
         * @param {string} [filterSeleniumResult] 
         * @param {string} [filterDone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllProjectResults(runID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, filterStartFrom?: string, filterStartTo?: string, filterEndFrom?: string, filterEndTo?: string, filterStatus?: string, filterSeleniumResult?: string, filterDone?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ProjectresultApiFetchParamCreator(configuration).readAllProjectResults(runID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, filterStartFrom, filterStartTo, filterEndFrom, filterEndTo, filterStatus, filterSeleniumResult, filterDone, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves single project run result info. Project, run and result must be previously created
         * @summary Read single project run result
         * @param {number} resultID 
         * @param {number} runID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectResult(resultID: number, runID: number, projectID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExtendedResult> {
            const localVarFetchArgs = ProjectresultApiFetchParamCreator(configuration).readProjectResult(resultID, runID, projectID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all project result statisctics. Project and run must be previously created
         * @summary Read all project result statistics
         * @param {number} runID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectResultStatistics(runID: number, projectID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = ProjectresultApiFetchParamCreator(configuration).readProjectResultStatistics(runID, projectID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectresultApi - factory interface
 * @export
 */
export const ProjectresultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint retrieves all project run results. Project, run must be previously created and run has to be finished in order to get results
         * @summary Read all project run results
         * @param {number} runID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {string} [filterStartFrom] 
         * @param {string} [filterStartTo] 
         * @param {string} [filterEndFrom] 
         * @param {string} [filterEndTo] 
         * @param {string} [filterStatus] 
         * @param {string} [filterSeleniumResult] 
         * @param {string} [filterDone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllProjectResults(runID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, filterStartFrom?: string, filterStartTo?: string, filterEndFrom?: string, filterEndTo?: string, filterStatus?: string, filterSeleniumResult?: string, filterDone?: string, options?: any) {
            return ProjectresultApiFp(configuration).readAllProjectResults(runID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, filterStartFrom, filterStartTo, filterEndFrom, filterEndTo, filterStatus, filterSeleniumResult, filterDone, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves single project run result info. Project, run and result must be previously created
         * @summary Read single project run result
         * @param {number} resultID 
         * @param {number} runID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectResult(resultID: number, runID: number, projectID: number, describe?: string, options?: any) {
            return ProjectresultApiFp(configuration).readProjectResult(resultID, runID, projectID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all project result statisctics. Project and run must be previously created
         * @summary Read all project result statistics
         * @param {number} runID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectResultStatistics(runID: number, projectID: number, describe?: string, options?: any) {
            return ProjectresultApiFp(configuration).readProjectResultStatistics(runID, projectID, describe, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectresultApi - object-oriented interface
 * @export
 * @class ProjectresultApi
 * @extends {BaseAPI}
 */
export class ProjectresultApi extends BaseAPI {
    /**
     * This endpoint retrieves all project run results. Project, run must be previously created and run has to be finished in order to get results
     * @summary Read all project run results
     * @param {number} runID 
     * @param {number} projectID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterBrowser] 
     * @param {string} [filterNetwork] 
     * @param {string} [filterLocation] 
     * @param {string} [filterMediaType] 
     * @param {string} [filterVideoFeed] 
     * @param {string} [filterAudioFeed] 
     * @param {string} [filterName] 
     * @param {string} [filterNumFrom] 
     * @param {string} [filterNumTo] 
     * @param {string} [filterGroupName] 
     * @param {string} [filterGroupNumFrom] 
     * @param {string} [filterGroupNumTo] 
     * @param {string} [filterRecordAudio] 
     * @param {string} [filterStartFrom] 
     * @param {string} [filterStartTo] 
     * @param {string} [filterEndFrom] 
     * @param {string} [filterEndTo] 
     * @param {string} [filterStatus] 
     * @param {string} [filterSeleniumResult] 
     * @param {string} [filterDone] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectresultApi
     */
    public readAllProjectResults(runID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, filterStartFrom?: string, filterStartTo?: string, filterEndFrom?: string, filterEndTo?: string, filterStatus?: string, filterSeleniumResult?: string, filterDone?: string, options?: any) {
        return ProjectresultApiFp(this.configuration).readAllProjectResults(runID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, filterStartFrom, filterStartTo, filterEndFrom, filterEndTo, filterStatus, filterSeleniumResult, filterDone, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves single project run result info. Project, run and result must be previously created
     * @summary Read single project run result
     * @param {number} resultID 
     * @param {number} runID 
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectresultApi
     */
    public readProjectResult(resultID: number, runID: number, projectID: number, describe?: string, options?: any) {
        return ProjectresultApiFp(this.configuration).readProjectResult(resultID, runID, projectID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all project result statisctics. Project and run must be previously created
     * @summary Read all project result statistics
     * @param {number} runID 
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectresultApi
     */
    public readProjectResultStatistics(runID: number, projectID: number, describe?: string, options?: any) {
        return ProjectresultApiFp(this.configuration).readProjectResultStatistics(runID, projectID, describe, options)(this.fetch, this.basePath);
    }

}
/**
 * ProjectrunApi - fetch parameter creator
 * @export
 */
export const ProjectrunApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all test run info. Project must be previously created
         * @summary Get all existing test runs for project
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterTestName] 
         * @param {string} [filterStartedFrom] 
         * @param {string} [filterStartedTo] 
         * @param {string} [filterFinishedFrom] 
         * @param {string} [filterFinishedTo] 
         * @param {string} [filterExecutionStartedFrom] 
         * @param {string} [filterExecutionStartedTo] 
         * @param {string} [filterExecutionFinishedFrom] 
         * @param {string} [filterExecutionFinishedTo] 
         * @param {string} [filterIncrementStrategy] 
         * @param {string} [filterStatus] 
         * @param {string} [filterTestMode] 
         * @param {string} [filterStartIntervalFrom] 
         * @param {string} [filterStartIntervalTo] 
         * @param {string} [filterParticipantTimeoutFrom] 
         * @param {string} [filterParticipantTimeoutTo] 
         * @param {string} [filterActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllProjectRuns(projectID: number, limit?: number, offset?: number, describe?: string, filterTestName?: string, filterStartedFrom?: string, filterStartedTo?: string, filterFinishedFrom?: string, filterFinishedTo?: string, filterExecutionStartedFrom?: string, filterExecutionStartedTo?: string, filterExecutionFinishedFrom?: string, filterExecutionFinishedTo?: string, filterIncrementStrategy?: string, filterStatus?: string, filterTestMode?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, filterActive?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllProjectRuns.');
            }
            const localVarPath = `/projects/{projectID}/runs/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterTestName !== undefined) {
                localVarQueryParameter['filter_test_name'] = filterTestName;
            }

            if (filterStartedFrom !== undefined) {
                localVarQueryParameter['filter_started_from'] = filterStartedFrom;
            }

            if (filterStartedTo !== undefined) {
                localVarQueryParameter['filter_started_to'] = filterStartedTo;
            }

            if (filterFinishedFrom !== undefined) {
                localVarQueryParameter['filter_finished_from'] = filterFinishedFrom;
            }

            if (filterFinishedTo !== undefined) {
                localVarQueryParameter['filter_finished_to'] = filterFinishedTo;
            }

            if (filterExecutionStartedFrom !== undefined) {
                localVarQueryParameter['filter_execution_started_from'] = filterExecutionStartedFrom;
            }

            if (filterExecutionStartedTo !== undefined) {
                localVarQueryParameter['filter_execution_started_to'] = filterExecutionStartedTo;
            }

            if (filterExecutionFinishedFrom !== undefined) {
                localVarQueryParameter['filter_execution_finished_from'] = filterExecutionFinishedFrom;
            }

            if (filterExecutionFinishedTo !== undefined) {
                localVarQueryParameter['filter_execution_finished_to'] = filterExecutionFinishedTo;
            }

            if (filterIncrementStrategy !== undefined) {
                localVarQueryParameter['filter_increment_strategy'] = filterIncrementStrategy;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter_status'] = filterStatus;
            }

            if (filterTestMode !== undefined) {
                localVarQueryParameter['filter_test_mode'] = filterTestMode;
            }

            if (filterStartIntervalFrom !== undefined) {
                localVarQueryParameter['filter_start_interval_from'] = filterStartIntervalFrom;
            }

            if (filterStartIntervalTo !== undefined) {
                localVarQueryParameter['filter_start_interval_to'] = filterStartIntervalTo;
            }

            if (filterParticipantTimeoutFrom !== undefined) {
                localVarQueryParameter['filter_participant_timeout_from'] = filterParticipantTimeoutFrom;
            }

            if (filterParticipantTimeoutTo !== undefined) {
                localVarQueryParameter['filter_participant_timeout_to'] = filterParticipantTimeoutTo;
            }

            if (filterActive !== undefined) {
                localVarQueryParameter['filter_active'] = filterActive;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves project test run info. Project and run must be previously created
         * @summary Read project test run info
         * @param {number} projectID 
         * @param {number} runID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectRun(projectID: number, runID: number, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readProjectRun.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readProjectRun.');
            }
            const localVarPath = `/projects/{projectID}/runs/{runID}/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectrunApi - functional programming interface
 * @export
 */
export const ProjectrunApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all test run info. Project must be previously created
         * @summary Get all existing test runs for project
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterTestName] 
         * @param {string} [filterStartedFrom] 
         * @param {string} [filterStartedTo] 
         * @param {string} [filterFinishedFrom] 
         * @param {string} [filterFinishedTo] 
         * @param {string} [filterExecutionStartedFrom] 
         * @param {string} [filterExecutionStartedTo] 
         * @param {string} [filterExecutionFinishedFrom] 
         * @param {string} [filterExecutionFinishedTo] 
         * @param {string} [filterIncrementStrategy] 
         * @param {string} [filterStatus] 
         * @param {string} [filterTestMode] 
         * @param {string} [filterStartIntervalFrom] 
         * @param {string} [filterStartIntervalTo] 
         * @param {string} [filterParticipantTimeoutFrom] 
         * @param {string} [filterParticipantTimeoutTo] 
         * @param {string} [filterActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllProjectRuns(projectID: number, limit?: number, offset?: number, describe?: string, filterTestName?: string, filterStartedFrom?: string, filterStartedTo?: string, filterFinishedFrom?: string, filterFinishedTo?: string, filterExecutionStartedFrom?: string, filterExecutionStartedTo?: string, filterExecutionFinishedFrom?: string, filterExecutionFinishedTo?: string, filterIncrementStrategy?: string, filterStatus?: string, filterTestMode?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, filterActive?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = ProjectrunApiFetchParamCreator(configuration).readAllProjectRuns(projectID, limit, offset, describe, filterTestName, filterStartedFrom, filterStartedTo, filterFinishedFrom, filterFinishedTo, filterExecutionStartedFrom, filterExecutionStartedTo, filterExecutionFinishedFrom, filterExecutionFinishedTo, filterIncrementStrategy, filterStatus, filterTestMode, filterStartIntervalFrom, filterStartIntervalTo, filterParticipantTimeoutFrom, filterParticipantTimeoutTo, filterActive, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves project test run info. Project and run must be previously created
         * @summary Read project test run info
         * @param {number} projectID 
         * @param {number} runID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectRun(projectID: number, runID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RunBody> {
            const localVarFetchArgs = ProjectrunApiFetchParamCreator(configuration).readProjectRun(projectID, runID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectrunApi - factory interface
 * @export
 */
export const ProjectrunApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint retrieves all test run info. Project must be previously created
         * @summary Get all existing test runs for project
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterTestName] 
         * @param {string} [filterStartedFrom] 
         * @param {string} [filterStartedTo] 
         * @param {string} [filterFinishedFrom] 
         * @param {string} [filterFinishedTo] 
         * @param {string} [filterExecutionStartedFrom] 
         * @param {string} [filterExecutionStartedTo] 
         * @param {string} [filterExecutionFinishedFrom] 
         * @param {string} [filterExecutionFinishedTo] 
         * @param {string} [filterIncrementStrategy] 
         * @param {string} [filterStatus] 
         * @param {string} [filterTestMode] 
         * @param {string} [filterStartIntervalFrom] 
         * @param {string} [filterStartIntervalTo] 
         * @param {string} [filterParticipantTimeoutFrom] 
         * @param {string} [filterParticipantTimeoutTo] 
         * @param {string} [filterActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllProjectRuns(projectID: number, limit?: number, offset?: number, describe?: string, filterTestName?: string, filterStartedFrom?: string, filterStartedTo?: string, filterFinishedFrom?: string, filterFinishedTo?: string, filterExecutionStartedFrom?: string, filterExecutionStartedTo?: string, filterExecutionFinishedFrom?: string, filterExecutionFinishedTo?: string, filterIncrementStrategy?: string, filterStatus?: string, filterTestMode?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, filterActive?: string, options?: any) {
            return ProjectrunApiFp(configuration).readAllProjectRuns(projectID, limit, offset, describe, filterTestName, filterStartedFrom, filterStartedTo, filterFinishedFrom, filterFinishedTo, filterExecutionStartedFrom, filterExecutionStartedTo, filterExecutionFinishedFrom, filterExecutionFinishedTo, filterIncrementStrategy, filterStatus, filterTestMode, filterStartIntervalFrom, filterStartIntervalTo, filterParticipantTimeoutFrom, filterParticipantTimeoutTo, filterActive, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves project test run info. Project and run must be previously created
         * @summary Read project test run info
         * @param {number} projectID 
         * @param {number} runID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectRun(projectID: number, runID: number, options?: any) {
            return ProjectrunApiFp(configuration).readProjectRun(projectID, runID, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectrunApi - object-oriented interface
 * @export
 * @class ProjectrunApi
 * @extends {BaseAPI}
 */
export class ProjectrunApi extends BaseAPI {
    /**
     * This endpoint retrieves all test run info. Project must be previously created
     * @summary Get all existing test runs for project
     * @param {number} projectID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterTestName] 
     * @param {string} [filterStartedFrom] 
     * @param {string} [filterStartedTo] 
     * @param {string} [filterFinishedFrom] 
     * @param {string} [filterFinishedTo] 
     * @param {string} [filterExecutionStartedFrom] 
     * @param {string} [filterExecutionStartedTo] 
     * @param {string} [filterExecutionFinishedFrom] 
     * @param {string} [filterExecutionFinishedTo] 
     * @param {string} [filterIncrementStrategy] 
     * @param {string} [filterStatus] 
     * @param {string} [filterTestMode] 
     * @param {string} [filterStartIntervalFrom] 
     * @param {string} [filterStartIntervalTo] 
     * @param {string} [filterParticipantTimeoutFrom] 
     * @param {string} [filterParticipantTimeoutTo] 
     * @param {string} [filterActive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectrunApi
     */
    public readAllProjectRuns(projectID: number, limit?: number, offset?: number, describe?: string, filterTestName?: string, filterStartedFrom?: string, filterStartedTo?: string, filterFinishedFrom?: string, filterFinishedTo?: string, filterExecutionStartedFrom?: string, filterExecutionStartedTo?: string, filterExecutionFinishedFrom?: string, filterExecutionFinishedTo?: string, filterIncrementStrategy?: string, filterStatus?: string, filterTestMode?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, filterActive?: string, options?: any) {
        return ProjectrunApiFp(this.configuration).readAllProjectRuns(projectID, limit, offset, describe, filterTestName, filterStartedFrom, filterStartedTo, filterFinishedFrom, filterFinishedTo, filterExecutionStartedFrom, filterExecutionStartedTo, filterExecutionFinishedFrom, filterExecutionFinishedTo, filterIncrementStrategy, filterStatus, filterTestMode, filterStartIntervalFrom, filterStartIntervalTo, filterParticipantTimeoutFrom, filterParticipantTimeoutTo, filterActive, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves project test run info. Project and run must be previously created
     * @summary Read project test run info
     * @param {number} projectID 
     * @param {number} runID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectrunApi
     */
    public readProjectRun(projectID: number, runID: number, options?: any) {
        return ProjectrunApiFp(this.configuration).readProjectRun(projectID, runID, options)(this.fetch, this.basePath);
    }

}
/**
 * ProjectrunparticipantApi - fetch parameter creator
 * @export
 */
export const ProjectrunparticipantApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all project run participant info.
         * @summary Get all existing project run participants for run
         * @param {number} runID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllProjectRunParticipants(runID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readAllProjectRunParticipants.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllProjectRunParticipants.');
            }
            const localVarPath = `/projects/{projectID}/runs/{runID}/participants/`
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterBrowser !== undefined) {
                localVarQueryParameter['filter_browser'] = filterBrowser;
            }

            if (filterNetwork !== undefined) {
                localVarQueryParameter['filter_network'] = filterNetwork;
            }

            if (filterLocation !== undefined) {
                localVarQueryParameter['filter_location'] = filterLocation;
            }

            if (filterMediaType !== undefined) {
                localVarQueryParameter['filter_media_type'] = filterMediaType;
            }

            if (filterVideoFeed !== undefined) {
                localVarQueryParameter['filter_video_feed'] = filterVideoFeed;
            }

            if (filterAudioFeed !== undefined) {
                localVarQueryParameter['filter_audio_feed'] = filterAudioFeed;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter_name'] = filterName;
            }

            if (filterNumFrom !== undefined) {
                localVarQueryParameter['filter_num_from'] = filterNumFrom;
            }

            if (filterNumTo !== undefined) {
                localVarQueryParameter['filter_num_to'] = filterNumTo;
            }

            if (filterGroupName !== undefined) {
                localVarQueryParameter['filter_group_name'] = filterGroupName;
            }

            if (filterGroupNumFrom !== undefined) {
                localVarQueryParameter['filter_group_num_from'] = filterGroupNumFrom;
            }

            if (filterGroupNumTo !== undefined) {
                localVarQueryParameter['filter_group_num_to'] = filterGroupNumTo;
            }

            if (filterRecordAudio !== undefined) {
                localVarQueryParameter['filter_record_audio'] = filterRecordAudio;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves project run participant info. Run, run participant must be previously created
         * @summary Get existing project run participant
         * @param {number} runParticipantID 
         * @param {number} runID 
         * @param {number} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectRunParticipant(runParticipantID: number, runID: number, projectID: number, options: any = {}): FetchArgs {
            // verify required parameter 'runParticipantID' is not null or undefined
            if (runParticipantID === null || runParticipantID === undefined) {
                throw new RequiredError('runParticipantID','Required parameter runParticipantID was null or undefined when calling readProjectRunParticipant.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readProjectRunParticipant.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readProjectRunParticipant.');
            }
            const localVarPath = `/projects/{projectID}/runs/{runID}/participants/{runParticipantID}/`
                .replace(`{${"runParticipantID"}}`, encodeURIComponent(String(runParticipantID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectrunparticipantApi - functional programming interface
 * @export
 */
export const ProjectrunparticipantApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all project run participant info.
         * @summary Get all existing project run participants for run
         * @param {number} runID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllProjectRunParticipants(runID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = ProjectrunparticipantApiFetchParamCreator(configuration).readAllProjectRunParticipants(runID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves project run participant info. Run, run participant must be previously created
         * @summary Get existing project run participant
         * @param {number} runParticipantID 
         * @param {number} runID 
         * @param {number} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectRunParticipant(runParticipantID: number, runID: number, projectID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RunParticipantBody> {
            const localVarFetchArgs = ProjectrunparticipantApiFetchParamCreator(configuration).readProjectRunParticipant(runParticipantID, runID, projectID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectrunparticipantApi - factory interface
 * @export
 */
export const ProjectrunparticipantApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint retrieves all project run participant info.
         * @summary Get all existing project run participants for run
         * @param {number} runID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllProjectRunParticipants(runID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, options?: any) {
            return ProjectrunparticipantApiFp(configuration).readAllProjectRunParticipants(runID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves project run participant info. Run, run participant must be previously created
         * @summary Get existing project run participant
         * @param {number} runParticipantID 
         * @param {number} runID 
         * @param {number} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readProjectRunParticipant(runParticipantID: number, runID: number, projectID: number, options?: any) {
            return ProjectrunparticipantApiFp(configuration).readProjectRunParticipant(runParticipantID, runID, projectID, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectrunparticipantApi - object-oriented interface
 * @export
 * @class ProjectrunparticipantApi
 * @extends {BaseAPI}
 */
export class ProjectrunparticipantApi extends BaseAPI {
    /**
     * This endpoint retrieves all project run participant info.
     * @summary Get all existing project run participants for run
     * @param {number} runID 
     * @param {number} projectID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterBrowser] 
     * @param {string} [filterNetwork] 
     * @param {string} [filterLocation] 
     * @param {string} [filterMediaType] 
     * @param {string} [filterVideoFeed] 
     * @param {string} [filterAudioFeed] 
     * @param {string} [filterName] 
     * @param {string} [filterNumFrom] 
     * @param {string} [filterNumTo] 
     * @param {string} [filterGroupName] 
     * @param {string} [filterGroupNumFrom] 
     * @param {string} [filterGroupNumTo] 
     * @param {string} [filterRecordAudio] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectrunparticipantApi
     */
    public readAllProjectRunParticipants(runID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, options?: any) {
        return ProjectrunparticipantApiFp(this.configuration).readAllProjectRunParticipants(runID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves project run participant info. Run, run participant must be previously created
     * @summary Get existing project run participant
     * @param {number} runParticipantID 
     * @param {number} runID 
     * @param {number} projectID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectrunparticipantApi
     */
    public readProjectRunParticipant(runParticipantID: number, runID: number, projectID: number, options?: any) {
        return ProjectrunparticipantApiFp(this.configuration).readProjectRunParticipant(runParticipantID, runID, projectID, options)(this.fetch, this.basePath);
    }

}
/**
 * ResultApi - fetch parameter creator
 * @export
 */
export const ResultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all test run results. Project, test, run must be previously created and run has to be finished in order to get results
         * @summary Read all test run results
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {string} [filterStartFrom] 
         * @param {string} [filterStartTo] 
         * @param {string} [filterEndFrom] 
         * @param {string} [filterEndTo] 
         * @param {string} [filterStatus] 
         * @param {string} [filterSeleniumResult] 
         * @param {string} [filterDone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTestResults(runID: number, testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, filterStartFrom?: string, filterStartTo?: string, filterEndFrom?: string, filterEndTo?: string, filterStatus?: string, filterSeleniumResult?: string, filterDone?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readAllTestResults.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readAllTestResults.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllTestResults.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/runs/{runID}/results/`
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterBrowser !== undefined) {
                localVarQueryParameter['filter_browser'] = filterBrowser;
            }

            if (filterNetwork !== undefined) {
                localVarQueryParameter['filter_network'] = filterNetwork;
            }

            if (filterLocation !== undefined) {
                localVarQueryParameter['filter_location'] = filterLocation;
            }

            if (filterMediaType !== undefined) {
                localVarQueryParameter['filter_media_type'] = filterMediaType;
            }

            if (filterVideoFeed !== undefined) {
                localVarQueryParameter['filter_video_feed'] = filterVideoFeed;
            }

            if (filterAudioFeed !== undefined) {
                localVarQueryParameter['filter_audio_feed'] = filterAudioFeed;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter_name'] = filterName;
            }

            if (filterNumFrom !== undefined) {
                localVarQueryParameter['filter_num_from'] = filterNumFrom;
            }

            if (filterNumTo !== undefined) {
                localVarQueryParameter['filter_num_to'] = filterNumTo;
            }

            if (filterGroupName !== undefined) {
                localVarQueryParameter['filter_group_name'] = filterGroupName;
            }

            if (filterGroupNumFrom !== undefined) {
                localVarQueryParameter['filter_group_num_from'] = filterGroupNumFrom;
            }

            if (filterGroupNumTo !== undefined) {
                localVarQueryParameter['filter_group_num_to'] = filterGroupNumTo;
            }

            if (filterRecordAudio !== undefined) {
                localVarQueryParameter['filter_record_audio'] = filterRecordAudio;
            }

            if (filterStartFrom !== undefined) {
                localVarQueryParameter['filter_start_from'] = filterStartFrom;
            }

            if (filterStartTo !== undefined) {
                localVarQueryParameter['filter_start_to'] = filterStartTo;
            }

            if (filterEndFrom !== undefined) {
                localVarQueryParameter['filter_end_from'] = filterEndFrom;
            }

            if (filterEndTo !== undefined) {
                localVarQueryParameter['filter_end_to'] = filterEndTo;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter_status'] = filterStatus;
            }

            if (filterSeleniumResult !== undefined) {
                localVarQueryParameter['filter_selenium_result'] = filterSeleniumResult;
            }

            if (filterDone !== undefined) {
                localVarQueryParameter['filter_done'] = filterDone;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves single test run result info. Project, test, run and result must be previously created
         * @summary Read single test run result
         * @param {number} resultID 
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestResult(resultID: number, runID: number, testID: number, projectID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'resultID' is not null or undefined
            if (resultID === null || resultID === undefined) {
                throw new RequiredError('resultID','Required parameter resultID was null or undefined when calling readTestResult.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readTestResult.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readTestResult.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readTestResult.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/runs/{runID}/results/{resultID}/`
                .replace(`{${"resultID"}}`, encodeURIComponent(String(resultID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all test result statisctics. Project, test and run must be previously created
         * @summary Read all test result statistics
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestResultStatistics(runID: number, testID: number, projectID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readTestResultStatistics.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readTestResultStatistics.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readTestResultStatistics.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/runs/{runID}/results/statistics/`
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResultApi - functional programming interface
 * @export
 */
export const ResultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all test run results. Project, test, run must be previously created and run has to be finished in order to get results
         * @summary Read all test run results
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {string} [filterStartFrom] 
         * @param {string} [filterStartTo] 
         * @param {string} [filterEndFrom] 
         * @param {string} [filterEndTo] 
         * @param {string} [filterStatus] 
         * @param {string} [filterSeleniumResult] 
         * @param {string} [filterDone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTestResults(runID: number, testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, filterStartFrom?: string, filterStartTo?: string, filterEndFrom?: string, filterEndTo?: string, filterStatus?: string, filterSeleniumResult?: string, filterDone?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
            const localVarFetchArgs = ResultApiFetchParamCreator(configuration).readAllTestResults(runID, testID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, filterStartFrom, filterStartTo, filterEndFrom, filterEndTo, filterStatus, filterSeleniumResult, filterDone, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves single test run result info. Project, test, run and result must be previously created
         * @summary Read single test run result
         * @param {number} resultID 
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestResult(resultID: number, runID: number, testID: number, projectID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExtendedResult> {
            const localVarFetchArgs = ResultApiFetchParamCreator(configuration).readTestResult(resultID, runID, testID, projectID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all test result statisctics. Project, test and run must be previously created
         * @summary Read all test result statistics
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestResultStatistics(runID: number, testID: number, projectID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
            const localVarFetchArgs = ResultApiFetchParamCreator(configuration).readTestResultStatistics(runID, testID, projectID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ResultApi - factory interface
 * @export
 */
export const ResultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint retrieves all test run results. Project, test, run must be previously created and run has to be finished in order to get results
         * @summary Read all test run results
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {string} [filterStartFrom] 
         * @param {string} [filterStartTo] 
         * @param {string} [filterEndFrom] 
         * @param {string} [filterEndTo] 
         * @param {string} [filterStatus] 
         * @param {string} [filterSeleniumResult] 
         * @param {string} [filterDone] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTestResults(runID: number, testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, filterStartFrom?: string, filterStartTo?: string, filterEndFrom?: string, filterEndTo?: string, filterStatus?: string, filterSeleniumResult?: string, filterDone?: string, options?: any) {
            return ResultApiFp(configuration).readAllTestResults(runID, testID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, filterStartFrom, filterStartTo, filterEndFrom, filterEndTo, filterStatus, filterSeleniumResult, filterDone, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves single test run result info. Project, test, run and result must be previously created
         * @summary Read single test run result
         * @param {number} resultID 
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestResult(resultID: number, runID: number, testID: number, projectID: number, describe?: string, options?: any) {
            return ResultApiFp(configuration).readTestResult(resultID, runID, testID, projectID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all test result statisctics. Project, test and run must be previously created
         * @summary Read all test result statistics
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestResultStatistics(runID: number, testID: number, projectID: number, describe?: string, options?: any) {
            return ResultApiFp(configuration).readTestResultStatistics(runID, testID, projectID, describe, options)(fetch, basePath);
        },
    };
};

/**
 * ResultApi - object-oriented interface
 * @export
 * @class ResultApi
 * @extends {BaseAPI}
 */
export class ResultApi extends BaseAPI {
    /**
     * This endpoint retrieves all test run results. Project, test, run must be previously created and run has to be finished in order to get results
     * @summary Read all test run results
     * @param {number} runID 
     * @param {number} testID 
     * @param {number} projectID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterBrowser] 
     * @param {string} [filterNetwork] 
     * @param {string} [filterLocation] 
     * @param {string} [filterMediaType] 
     * @param {string} [filterVideoFeed] 
     * @param {string} [filterAudioFeed] 
     * @param {string} [filterName] 
     * @param {string} [filterNumFrom] 
     * @param {string} [filterNumTo] 
     * @param {string} [filterGroupName] 
     * @param {string} [filterGroupNumFrom] 
     * @param {string} [filterGroupNumTo] 
     * @param {string} [filterRecordAudio] 
     * @param {string} [filterStartFrom] 
     * @param {string} [filterStartTo] 
     * @param {string} [filterEndFrom] 
     * @param {string} [filterEndTo] 
     * @param {string} [filterStatus] 
     * @param {string} [filterSeleniumResult] 
     * @param {string} [filterDone] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultApi
     */
    public readAllTestResults(runID: number, testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, filterStartFrom?: string, filterStartTo?: string, filterEndFrom?: string, filterEndTo?: string, filterStatus?: string, filterSeleniumResult?: string, filterDone?: string, options?: any) {
        return ResultApiFp(this.configuration).readAllTestResults(runID, testID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, filterStartFrom, filterStartTo, filterEndFrom, filterEndTo, filterStatus, filterSeleniumResult, filterDone, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves single test run result info. Project, test, run and result must be previously created
     * @summary Read single test run result
     * @param {number} resultID 
     * @param {number} runID 
     * @param {number} testID 
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultApi
     */
    public readTestResult(resultID: number, runID: number, testID: number, projectID: number, describe?: string, options?: any) {
        return ResultApiFp(this.configuration).readTestResult(resultID, runID, testID, projectID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all test result statisctics. Project, test and run must be previously created
     * @summary Read all test result statistics
     * @param {number} runID 
     * @param {number} testID 
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResultApi
     */
    public readTestResultStatistics(runID: number, testID: number, projectID: number, describe?: string, options?: any) {
        return ResultApiFp(this.configuration).readTestResultStatistics(runID, testID, projectID, describe, options)(this.fetch, this.basePath);
    }

}
/**
 * RunApi - fetch parameter creator
 * @export
 */
export const RunApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint starts test execution. Project and test must be previously created
         * @summary Create and launch new test run
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestRun(testID: number, projectID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling createTestRun.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling createTestRun.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/runs/`
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all test run info. Project and test must be previously created
         * @summary Get all existing test runs for test
         * @param {number} testID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterTestName] 
         * @param {string} [filterStartedFrom] 
         * @param {string} [filterStartedTo] 
         * @param {string} [filterFinishedFrom] 
         * @param {string} [filterFinishedTo] 
         * @param {string} [filterExecutionStartedFrom] 
         * @param {string} [filterExecutionStartedTo] 
         * @param {string} [filterExecutionFinishedFrom] 
         * @param {string} [filterExecutionFinishedTo] 
         * @param {string} [filterIncrementStrategy] 
         * @param {string} [filterStatus] 
         * @param {string} [filterTestMode] 
         * @param {string} [filterStartIntervalFrom] 
         * @param {string} [filterStartIntervalTo] 
         * @param {string} [filterParticipantTimeoutFrom] 
         * @param {string} [filterParticipantTimeoutTo] 
         * @param {string} [filterActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTestRuns(testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterTestName?: string, filterStartedFrom?: string, filterStartedTo?: string, filterFinishedFrom?: string, filterFinishedTo?: string, filterExecutionStartedFrom?: string, filterExecutionStartedTo?: string, filterExecutionFinishedFrom?: string, filterExecutionFinishedTo?: string, filterIncrementStrategy?: string, filterStatus?: string, filterTestMode?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, filterActive?: string, options: any = {}): FetchArgs {
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readAllTestRuns.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllTestRuns.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/runs/`
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterTestName !== undefined) {
                localVarQueryParameter['filter_test_name'] = filterTestName;
            }

            if (filterStartedFrom !== undefined) {
                localVarQueryParameter['filter_started_from'] = filterStartedFrom;
            }

            if (filterStartedTo !== undefined) {
                localVarQueryParameter['filter_started_to'] = filterStartedTo;
            }

            if (filterFinishedFrom !== undefined) {
                localVarQueryParameter['filter_finished_from'] = filterFinishedFrom;
            }

            if (filterFinishedTo !== undefined) {
                localVarQueryParameter['filter_finished_to'] = filterFinishedTo;
            }

            if (filterExecutionStartedFrom !== undefined) {
                localVarQueryParameter['filter_execution_started_from'] = filterExecutionStartedFrom;
            }

            if (filterExecutionStartedTo !== undefined) {
                localVarQueryParameter['filter_execution_started_to'] = filterExecutionStartedTo;
            }

            if (filterExecutionFinishedFrom !== undefined) {
                localVarQueryParameter['filter_execution_finished_from'] = filterExecutionFinishedFrom;
            }

            if (filterExecutionFinishedTo !== undefined) {
                localVarQueryParameter['filter_execution_finished_to'] = filterExecutionFinishedTo;
            }

            if (filterIncrementStrategy !== undefined) {
                localVarQueryParameter['filter_increment_strategy'] = filterIncrementStrategy;
            }

            if (filterStatus !== undefined) {
                localVarQueryParameter['filter_status'] = filterStatus;
            }

            if (filterTestMode !== undefined) {
                localVarQueryParameter['filter_test_mode'] = filterTestMode;
            }

            if (filterStartIntervalFrom !== undefined) {
                localVarQueryParameter['filter_start_interval_from'] = filterStartIntervalFrom;
            }

            if (filterStartIntervalTo !== undefined) {
                localVarQueryParameter['filter_start_interval_to'] = filterStartIntervalTo;
            }

            if (filterParticipantTimeoutFrom !== undefined) {
                localVarQueryParameter['filter_participant_timeout_from'] = filterParticipantTimeoutFrom;
            }

            if (filterParticipantTimeoutTo !== undefined) {
                localVarQueryParameter['filter_participant_timeout_to'] = filterParticipantTimeoutTo;
            }

            if (filterActive !== undefined) {
                localVarQueryParameter['filter_active'] = filterActive;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves test run info. Project, test and run must be previously created
         * @summary Read test run info
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestRun(runID: number, testID: number, projectID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readTestRun.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readTestRun.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readTestRun.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/runs/{runID}/`
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint stops test run. Project, test and run must be previously created. Test run needs to be in progress.
         * @summary Stop test run
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTestRun(runID: number, testID: number, projectID: number, options: any = {}): FetchArgs {
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling stopTestRun.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling stopTestRun.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling stopTestRun.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/runs/{runID}/stop/`
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunApi - functional programming interface
 * @export
 */
export const RunApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint starts test execution. Project and test must be previously created
         * @summary Create and launch new test run
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestRun(testID: number, projectID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Run> {
            const localVarFetchArgs = RunApiFetchParamCreator(configuration).createTestRun(testID, projectID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all test run info. Project and test must be previously created
         * @summary Get all existing test runs for test
         * @param {number} testID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterTestName] 
         * @param {string} [filterStartedFrom] 
         * @param {string} [filterStartedTo] 
         * @param {string} [filterFinishedFrom] 
         * @param {string} [filterFinishedTo] 
         * @param {string} [filterExecutionStartedFrom] 
         * @param {string} [filterExecutionStartedTo] 
         * @param {string} [filterExecutionFinishedFrom] 
         * @param {string} [filterExecutionFinishedTo] 
         * @param {string} [filterIncrementStrategy] 
         * @param {string} [filterStatus] 
         * @param {string} [filterTestMode] 
         * @param {string} [filterStartIntervalFrom] 
         * @param {string} [filterStartIntervalTo] 
         * @param {string} [filterParticipantTimeoutFrom] 
         * @param {string} [filterParticipantTimeoutTo] 
         * @param {string} [filterActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTestRuns(testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterTestName?: string, filterStartedFrom?: string, filterStartedTo?: string, filterFinishedFrom?: string, filterFinishedTo?: string, filterExecutionStartedFrom?: string, filterExecutionStartedTo?: string, filterExecutionFinishedFrom?: string, filterExecutionFinishedTo?: string, filterIncrementStrategy?: string, filterStatus?: string, filterTestMode?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, filterActive?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = RunApiFetchParamCreator(configuration).readAllTestRuns(testID, projectID, limit, offset, describe, filterTestName, filterStartedFrom, filterStartedTo, filterFinishedFrom, filterFinishedTo, filterExecutionStartedFrom, filterExecutionStartedTo, filterExecutionFinishedFrom, filterExecutionFinishedTo, filterIncrementStrategy, filterStatus, filterTestMode, filterStartIntervalFrom, filterStartIntervalTo, filterParticipantTimeoutFrom, filterParticipantTimeoutTo, filterActive, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves test run info. Project, test and run must be previously created
         * @summary Read test run info
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestRun(runID: number, testID: number, projectID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RunBody> {
            const localVarFetchArgs = RunApiFetchParamCreator(configuration).readTestRun(runID, testID, projectID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint stops test run. Project, test and run must be previously created. Test run needs to be in progress.
         * @summary Stop test run
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTestRun(runID: number, testID: number, projectID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = RunApiFetchParamCreator(configuration).stopTestRun(runID, testID, projectID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunApi - factory interface
 * @export
 */
export const RunApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint starts test execution. Project and test must be previously created
         * @summary Create and launch new test run
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTestRun(testID: number, projectID: number, describe?: string, options?: any) {
            return RunApiFp(configuration).createTestRun(testID, projectID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all test run info. Project and test must be previously created
         * @summary Get all existing test runs for test
         * @param {number} testID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterTestName] 
         * @param {string} [filterStartedFrom] 
         * @param {string} [filterStartedTo] 
         * @param {string} [filterFinishedFrom] 
         * @param {string} [filterFinishedTo] 
         * @param {string} [filterExecutionStartedFrom] 
         * @param {string} [filterExecutionStartedTo] 
         * @param {string} [filterExecutionFinishedFrom] 
         * @param {string} [filterExecutionFinishedTo] 
         * @param {string} [filterIncrementStrategy] 
         * @param {string} [filterStatus] 
         * @param {string} [filterTestMode] 
         * @param {string} [filterStartIntervalFrom] 
         * @param {string} [filterStartIntervalTo] 
         * @param {string} [filterParticipantTimeoutFrom] 
         * @param {string} [filterParticipantTimeoutTo] 
         * @param {string} [filterActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTestRuns(testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterTestName?: string, filterStartedFrom?: string, filterStartedTo?: string, filterFinishedFrom?: string, filterFinishedTo?: string, filterExecutionStartedFrom?: string, filterExecutionStartedTo?: string, filterExecutionFinishedFrom?: string, filterExecutionFinishedTo?: string, filterIncrementStrategy?: string, filterStatus?: string, filterTestMode?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, filterActive?: string, options?: any) {
            return RunApiFp(configuration).readAllTestRuns(testID, projectID, limit, offset, describe, filterTestName, filterStartedFrom, filterStartedTo, filterFinishedFrom, filterFinishedTo, filterExecutionStartedFrom, filterExecutionStartedTo, filterExecutionFinishedFrom, filterExecutionFinishedTo, filterIncrementStrategy, filterStatus, filterTestMode, filterStartIntervalFrom, filterStartIntervalTo, filterParticipantTimeoutFrom, filterParticipantTimeoutTo, filterActive, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves test run info. Project, test and run must be previously created
         * @summary Read test run info
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestRun(runID: number, testID: number, projectID: number, describe?: string, options?: any) {
            return RunApiFp(configuration).readTestRun(runID, testID, projectID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint stops test run. Project, test and run must be previously created. Test run needs to be in progress.
         * @summary Stop test run
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopTestRun(runID: number, testID: number, projectID: number, options?: any) {
            return RunApiFp(configuration).stopTestRun(runID, testID, projectID, options)(fetch, basePath);
        },
    };
};

/**
 * RunApi - object-oriented interface
 * @export
 * @class RunApi
 * @extends {BaseAPI}
 */
export class RunApi extends BaseAPI {
    /**
     * This endpoint starts test execution. Project and test must be previously created
     * @summary Create and launch new test run
     * @param {number} testID 
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public createTestRun(testID: number, projectID: number, describe?: string, options?: any) {
        return RunApiFp(this.configuration).createTestRun(testID, projectID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all test run info. Project and test must be previously created
     * @summary Get all existing test runs for test
     * @param {number} testID 
     * @param {number} projectID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterTestName] 
     * @param {string} [filterStartedFrom] 
     * @param {string} [filterStartedTo] 
     * @param {string} [filterFinishedFrom] 
     * @param {string} [filterFinishedTo] 
     * @param {string} [filterExecutionStartedFrom] 
     * @param {string} [filterExecutionStartedTo] 
     * @param {string} [filterExecutionFinishedFrom] 
     * @param {string} [filterExecutionFinishedTo] 
     * @param {string} [filterIncrementStrategy] 
     * @param {string} [filterStatus] 
     * @param {string} [filterTestMode] 
     * @param {string} [filterStartIntervalFrom] 
     * @param {string} [filterStartIntervalTo] 
     * @param {string} [filterParticipantTimeoutFrom] 
     * @param {string} [filterParticipantTimeoutTo] 
     * @param {string} [filterActive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public readAllTestRuns(testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterTestName?: string, filterStartedFrom?: string, filterStartedTo?: string, filterFinishedFrom?: string, filterFinishedTo?: string, filterExecutionStartedFrom?: string, filterExecutionStartedTo?: string, filterExecutionFinishedFrom?: string, filterExecutionFinishedTo?: string, filterIncrementStrategy?: string, filterStatus?: string, filterTestMode?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, filterActive?: string, options?: any) {
        return RunApiFp(this.configuration).readAllTestRuns(testID, projectID, limit, offset, describe, filterTestName, filterStartedFrom, filterStartedTo, filterFinishedFrom, filterFinishedTo, filterExecutionStartedFrom, filterExecutionStartedTo, filterExecutionFinishedFrom, filterExecutionFinishedTo, filterIncrementStrategy, filterStatus, filterTestMode, filterStartIntervalFrom, filterStartIntervalTo, filterParticipantTimeoutFrom, filterParticipantTimeoutTo, filterActive, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves test run info. Project, test and run must be previously created
     * @summary Read test run info
     * @param {number} runID 
     * @param {number} testID 
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public readTestRun(runID: number, testID: number, projectID: number, describe?: string, options?: any) {
        return RunApiFp(this.configuration).readTestRun(runID, testID, projectID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint stops test run. Project, test and run must be previously created. Test run needs to be in progress.
     * @summary Stop test run
     * @param {number} runID 
     * @param {number} testID 
     * @param {number} projectID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunApi
     */
    public stopTestRun(runID: number, testID: number, projectID: number, options?: any) {
        return RunApiFp(this.configuration).stopTestRun(runID, testID, projectID, options)(this.fetch, this.basePath);
    }

}
/**
 * RunparticipantApi - fetch parameter creator
 * @export
 */
export const RunparticipantApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all test run participant info.
         * @summary Get all existing test run participants for run
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTestRunParticipants(runID: number, testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readAllTestRunParticipants.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readAllTestRunParticipants.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllTestRunParticipants.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/runs/{runID}/participants/`
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterBrowser !== undefined) {
                localVarQueryParameter['filter_browser'] = filterBrowser;
            }

            if (filterNetwork !== undefined) {
                localVarQueryParameter['filter_network'] = filterNetwork;
            }

            if (filterLocation !== undefined) {
                localVarQueryParameter['filter_location'] = filterLocation;
            }

            if (filterMediaType !== undefined) {
                localVarQueryParameter['filter_media_type'] = filterMediaType;
            }

            if (filterVideoFeed !== undefined) {
                localVarQueryParameter['filter_video_feed'] = filterVideoFeed;
            }

            if (filterAudioFeed !== undefined) {
                localVarQueryParameter['filter_audio_feed'] = filterAudioFeed;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter_name'] = filterName;
            }

            if (filterNumFrom !== undefined) {
                localVarQueryParameter['filter_num_from'] = filterNumFrom;
            }

            if (filterNumTo !== undefined) {
                localVarQueryParameter['filter_num_to'] = filterNumTo;
            }

            if (filterGroupName !== undefined) {
                localVarQueryParameter['filter_group_name'] = filterGroupName;
            }

            if (filterGroupNumFrom !== undefined) {
                localVarQueryParameter['filter_group_num_from'] = filterGroupNumFrom;
            }

            if (filterGroupNumTo !== undefined) {
                localVarQueryParameter['filter_group_num_to'] = filterGroupNumTo;
            }

            if (filterRecordAudio !== undefined) {
                localVarQueryParameter['filter_record_audio'] = filterRecordAudio;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves test run participant info. Run, run participant must be previously created
         * @summary Get existing test run participant
         * @param {number} runParticipantID 
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestRunParticipant(runParticipantID: number, runID: number, testID: number, projectID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'runParticipantID' is not null or undefined
            if (runParticipantID === null || runParticipantID === undefined) {
                throw new RequiredError('runParticipantID','Required parameter runParticipantID was null or undefined when calling readTestRunParticipant.');
            }
            // verify required parameter 'runID' is not null or undefined
            if (runID === null || runID === undefined) {
                throw new RequiredError('runID','Required parameter runID was null or undefined when calling readTestRunParticipant.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readTestRunParticipant.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readTestRunParticipant.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/runs/{runID}/participants/{runParticipantID}/`
                .replace(`{${"runParticipantID"}}`, encodeURIComponent(String(runParticipantID)))
                .replace(`{${"runID"}}`, encodeURIComponent(String(runID)))
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunparticipantApi - functional programming interface
 * @export
 */
export const RunparticipantApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all test run participant info.
         * @summary Get all existing test run participants for run
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTestRunParticipants(runID: number, testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = RunparticipantApiFetchParamCreator(configuration).readAllTestRunParticipants(runID, testID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves test run participant info. Run, run participant must be previously created
         * @summary Get existing test run participant
         * @param {number} runParticipantID 
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestRunParticipant(runParticipantID: number, runID: number, testID: number, projectID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RunParticipantBody> {
            const localVarFetchArgs = RunparticipantApiFetchParamCreator(configuration).readTestRunParticipant(runParticipantID, runID, testID, projectID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RunparticipantApi - factory interface
 * @export
 */
export const RunparticipantApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint retrieves all test run participant info.
         * @summary Get all existing test run participants for run
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterBrowser] 
         * @param {string} [filterNetwork] 
         * @param {string} [filterLocation] 
         * @param {string} [filterMediaType] 
         * @param {string} [filterVideoFeed] 
         * @param {string} [filterAudioFeed] 
         * @param {string} [filterName] 
         * @param {string} [filterNumFrom] 
         * @param {string} [filterNumTo] 
         * @param {string} [filterGroupName] 
         * @param {string} [filterGroupNumFrom] 
         * @param {string} [filterGroupNumTo] 
         * @param {string} [filterRecordAudio] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTestRunParticipants(runID: number, testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, options?: any) {
            return RunparticipantApiFp(configuration).readAllTestRunParticipants(runID, testID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves test run participant info. Run, run participant must be previously created
         * @summary Get existing test run participant
         * @param {number} runParticipantID 
         * @param {number} runID 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTestRunParticipant(runParticipantID: number, runID: number, testID: number, projectID: number, describe?: string, options?: any) {
            return RunparticipantApiFp(configuration).readTestRunParticipant(runParticipantID, runID, testID, projectID, describe, options)(fetch, basePath);
        },
    };
};

/**
 * RunparticipantApi - object-oriented interface
 * @export
 * @class RunparticipantApi
 * @extends {BaseAPI}
 */
export class RunparticipantApi extends BaseAPI {
    /**
     * This endpoint retrieves all test run participant info.
     * @summary Get all existing test run participants for run
     * @param {number} runID 
     * @param {number} testID 
     * @param {number} projectID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterBrowser] 
     * @param {string} [filterNetwork] 
     * @param {string} [filterLocation] 
     * @param {string} [filterMediaType] 
     * @param {string} [filterVideoFeed] 
     * @param {string} [filterAudioFeed] 
     * @param {string} [filterName] 
     * @param {string} [filterNumFrom] 
     * @param {string} [filterNumTo] 
     * @param {string} [filterGroupName] 
     * @param {string} [filterGroupNumFrom] 
     * @param {string} [filterGroupNumTo] 
     * @param {string} [filterRecordAudio] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunparticipantApi
     */
    public readAllTestRunParticipants(runID: number, testID: number, projectID: number, limit?: number, offset?: number, describe?: string, filterBrowser?: string, filterNetwork?: string, filterLocation?: string, filterMediaType?: string, filterVideoFeed?: string, filterAudioFeed?: string, filterName?: string, filterNumFrom?: string, filterNumTo?: string, filterGroupName?: string, filterGroupNumFrom?: string, filterGroupNumTo?: string, filterRecordAudio?: string, options?: any) {
        return RunparticipantApiFp(this.configuration).readAllTestRunParticipants(runID, testID, projectID, limit, offset, describe, filterBrowser, filterNetwork, filterLocation, filterMediaType, filterVideoFeed, filterAudioFeed, filterName, filterNumFrom, filterNumTo, filterGroupName, filterGroupNumFrom, filterGroupNumTo, filterRecordAudio, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves test run participant info. Run, run participant must be previously created
     * @summary Get existing test run participant
     * @param {number} runParticipantID 
     * @param {number} runID 
     * @param {number} testID 
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunparticipantApi
     */
    public readTestRunParticipant(runParticipantID: number, runID: number, testID: number, projectID: number, describe?: string, options?: any) {
        return RunparticipantApiFp(this.configuration).readTestRunParticipant(runParticipantID, runID, testID, projectID, describe, options)(this.fetch, this.basePath);
    }

}
/**
 * StaticApi - fetch parameter creator
 * @export
 */
export const StaticApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all static type info
         * @summary Read all static type info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllStaticTypes(options: any = {}): FetchArgs {
            const localVarPath = `/statics/types/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all static resource info
         * @summary Read all static resource info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllStatics(options: any = {}): FetchArgs {
            const localVarPath = `/statics/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all available metric paths
         * @summary Read all metric path info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMetricPath(options: any = {}): FetchArgs {
            const localVarPath = `/statics/metric_path/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all specified static resource info
         * @summary Read all specified static resource info
         * @param {string} resource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStaticResource(resource: string, options: any = {}): FetchArgs {
            // verify required parameter 'resource' is not null or undefined
            if (resource === null || resource === undefined) {
                throw new RequiredError('resource','Required parameter resource was null or undefined when calling readStaticResource.');
            }
            const localVarPath = `/statics/{resource}/`
                .replace(`{${"resource"}}`, encodeURIComponent(String(resource)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaticApi - functional programming interface
 * @export
 */
export const StaticApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint retrieves all static type info
         * @summary Read all static type info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllStaticTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = StaticApiFetchParamCreator(configuration).readAllStaticTypes(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all static resource info
         * @summary Read all static resource info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllStatics(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: Array<BaseClassificator>; }> {
            const localVarFetchArgs = StaticApiFetchParamCreator(configuration).readAllStatics(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all available metric paths
         * @summary Read all metric path info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMetricPath(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = StaticApiFetchParamCreator(configuration).readMetricPath(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all specified static resource info
         * @summary Read all specified static resource info
         * @param {string} resource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStaticResource(resource: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BaseClassificator>> {
            const localVarFetchArgs = StaticApiFetchParamCreator(configuration).readStaticResource(resource, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StaticApi - factory interface
 * @export
 */
export const StaticApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint retrieves all static type info
         * @summary Read all static type info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllStaticTypes(options?: any) {
            return StaticApiFp(configuration).readAllStaticTypes(options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all static resource info
         * @summary Read all static resource info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllStatics(options?: any) {
            return StaticApiFp(configuration).readAllStatics(options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all available metric paths
         * @summary Read all metric path info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readMetricPath(options?: any) {
            return StaticApiFp(configuration).readMetricPath(options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all specified static resource info
         * @summary Read all specified static resource info
         * @param {string} resource 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readStaticResource(resource: string, options?: any) {
            return StaticApiFp(configuration).readStaticResource(resource, options)(fetch, basePath);
        },
    };
};

/**
 * StaticApi - object-oriented interface
 * @export
 * @class StaticApi
 * @extends {BaseAPI}
 */
export class StaticApi extends BaseAPI {
    /**
     * This endpoint retrieves all static type info
     * @summary Read all static type info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticApi
     */
    public readAllStaticTypes(options?: any) {
        return StaticApiFp(this.configuration).readAllStaticTypes(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all static resource info
     * @summary Read all static resource info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticApi
     */
    public readAllStatics(options?: any) {
        return StaticApiFp(this.configuration).readAllStatics(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all available metric paths
     * @summary Read all metric path info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticApi
     */
    public readMetricPath(options?: any) {
        return StaticApiFp(this.configuration).readMetricPath(options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all specified static resource info
     * @summary Read all specified static resource info
     * @param {string} resource 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticApi
     */
    public readStaticResource(resource: string, options?: any) {
        return StaticApiFp(this.configuration).readStaticResource(resource, options)(this.fetch, this.basePath);
    }

}
/**
 * TestApi - fetch parameter creator
 * @export
 */
export const TestApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new test with given data.
         * @summary Create new test
         * @param {string} name 
         * @param {number} startInterval 
         * @param {number} participantTimeout 
         * @param {string} mode 
         * @param {string} incrementStrategy 
         * @param {string} script 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {number} [id] readonly: true
         * @param {Date} [created] readonly: true
         * @param {Date} [updated] readonly: true
         * @param {number} [projectId] readonly: true
         * @param {number} [scriptFileId] readonly: true
         * @param {boolean} [deleted] readonly: true
         * @param {number} [groupCount] readonly: true
         * @param {number} [participantCount] readonly: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTest(name: string, startInterval: number, participantTimeout: number, mode: string, incrementStrategy: string, script: string, projectID: number, describe?: string, id?: number, created?: Date, updated?: Date, projectId?: number, scriptFileId?: number, deleted?: boolean, groupCount?: number, participantCount?: number, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createTest.');
            }
            // verify required parameter 'startInterval' is not null or undefined
            if (startInterval === null || startInterval === undefined) {
                throw new RequiredError('startInterval','Required parameter startInterval was null or undefined when calling createTest.');
            }
            // verify required parameter 'participantTimeout' is not null or undefined
            if (participantTimeout === null || participantTimeout === undefined) {
                throw new RequiredError('participantTimeout','Required parameter participantTimeout was null or undefined when calling createTest.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling createTest.');
            }
            // verify required parameter 'incrementStrategy' is not null or undefined
            if (incrementStrategy === null || incrementStrategy === undefined) {
                throw new RequiredError('incrementStrategy','Required parameter incrementStrategy was null or undefined when calling createTest.');
            }
            // verify required parameter 'script' is not null or undefined
            if (script === null || script === undefined) {
                throw new RequiredError('script','Required parameter script was null or undefined when calling createTest.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling createTest.');
            }
            const localVarPath = `/projects/{projectID}/tests/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = (created as any).toISOString();
            }

            if (updated !== undefined) {
                localVarQueryParameter['updated'] = (updated as any).toISOString();
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (scriptFileId !== undefined) {
                localVarQueryParameter['script_file_id'] = scriptFileId;
            }

            if (startInterval !== undefined) {
                localVarQueryParameter['start_interval'] = startInterval;
            }

            if (participantTimeout !== undefined) {
                localVarQueryParameter['participant_timeout'] = participantTimeout;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (incrementStrategy !== undefined) {
                localVarQueryParameter['increment_strategy'] = incrementStrategy;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (groupCount !== undefined) {
                localVarQueryParameter['group_count'] = groupCount;
            }

            if (participantCount !== undefined) {
                localVarQueryParameter['participant_count'] = participantCount;
            }

            if (script !== undefined) {
                localVarQueryParameter['script'] = script;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint deletes test. Project and test must be previously created
         * @summary Delete existing test
         * @param {number} testID 
         * @param {number} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTest(testID: number, projectID: number, options: any = {}): FetchArgs {
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling deleteTest.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling deleteTest.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/`
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint duplicates given test. If no copy name is provided an \"Copy of\" prefix will be applied to the test name. Project and test must be previously created.
         * @summary Duplicate existing test
         * @param {number} testID 
         * @param {number} projectID 
         * @param {TestIDCopyBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateTest(testID: number, projectID: number, body?: TestIDCopyBody, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling duplicateTest.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling duplicateTest.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/copy/`
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TestIDCopyBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves all test info. Project must be previously created
         * @summary Get all existing tests for project
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterName] 
         * @param {string} [filterTestMode] 
         * @param {string} [filterIncrementStrategy] 
         * @param {string} [filterStartIntervalFrom] 
         * @param {string} [filterStartIntervalTo] 
         * @param {string} [filterParticipantTimeoutFrom] 
         * @param {string} [filterParticipantTimeoutTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTests(projectID: number, limit?: number, offset?: number, describe?: string, filterName?: string, filterTestMode?: string, filterIncrementStrategy?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, options: any = {}): FetchArgs {
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readAllTests.');
            }
            const localVarPath = `/projects/{projectID}/tests/`
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (filterName !== undefined) {
                localVarQueryParameter['filter_name'] = filterName;
            }

            if (filterTestMode !== undefined) {
                localVarQueryParameter['filter_test_mode'] = filterTestMode;
            }

            if (filterIncrementStrategy !== undefined) {
                localVarQueryParameter['filter_increment_strategy'] = filterIncrementStrategy;
            }

            if (filterStartIntervalFrom !== undefined) {
                localVarQueryParameter['filter_start_interval_from'] = filterStartIntervalFrom;
            }

            if (filterStartIntervalTo !== undefined) {
                localVarQueryParameter['filter_start_interval_to'] = filterStartIntervalTo;
            }

            if (filterParticipantTimeoutFrom !== undefined) {
                localVarQueryParameter['filter_participant_timeout_from'] = filterParticipantTimeoutFrom;
            }

            if (filterParticipantTimeoutTo !== undefined) {
                localVarQueryParameter['filter_participant_timeout_to'] = filterParticipantTimeoutTo;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint retrieves test info. Project and test must be previously created
         * @summary Read test info
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTest(testID: number, projectID: number, describe?: string, options: any = {}): FetchArgs {
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling readTest.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling readTest.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/`
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint updates test with given properties. Project and test must be previously created
         * @summary Update existing test
         * @param {string} name 
         * @param {number} startInterval 
         * @param {number} participantTimeout 
         * @param {string} mode 
         * @param {string} incrementStrategy 
         * @param {string} script 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {number} [id] readonly: true
         * @param {Date} [created] readonly: true
         * @param {Date} [updated] readonly: true
         * @param {number} [projectId] readonly: true
         * @param {number} [scriptFileId] readonly: true
         * @param {boolean} [deleted] readonly: true
         * @param {number} [groupCount] readonly: true
         * @param {number} [participantCount] readonly: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTest(name: string, startInterval: number, participantTimeout: number, mode: string, incrementStrategy: string, script: string, testID: number, projectID: number, describe?: string, id?: number, created?: Date, updated?: Date, projectId?: number, scriptFileId?: number, deleted?: boolean, groupCount?: number, participantCount?: number, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateTest.');
            }
            // verify required parameter 'startInterval' is not null or undefined
            if (startInterval === null || startInterval === undefined) {
                throw new RequiredError('startInterval','Required parameter startInterval was null or undefined when calling updateTest.');
            }
            // verify required parameter 'participantTimeout' is not null or undefined
            if (participantTimeout === null || participantTimeout === undefined) {
                throw new RequiredError('participantTimeout','Required parameter participantTimeout was null or undefined when calling updateTest.');
            }
            // verify required parameter 'mode' is not null or undefined
            if (mode === null || mode === undefined) {
                throw new RequiredError('mode','Required parameter mode was null or undefined when calling updateTest.');
            }
            // verify required parameter 'incrementStrategy' is not null or undefined
            if (incrementStrategy === null || incrementStrategy === undefined) {
                throw new RequiredError('incrementStrategy','Required parameter incrementStrategy was null or undefined when calling updateTest.');
            }
            // verify required parameter 'script' is not null or undefined
            if (script === null || script === undefined) {
                throw new RequiredError('script','Required parameter script was null or undefined when calling updateTest.');
            }
            // verify required parameter 'testID' is not null or undefined
            if (testID === null || testID === undefined) {
                throw new RequiredError('testID','Required parameter testID was null or undefined when calling updateTest.');
            }
            // verify required parameter 'projectID' is not null or undefined
            if (projectID === null || projectID === undefined) {
                throw new RequiredError('projectID','Required parameter projectID was null or undefined when calling updateTest.');
            }
            const localVarPath = `/projects/{projectID}/tests/{testID}/`
                .replace(`{${"testID"}}`, encodeURIComponent(String(testID)))
                .replace(`{${"projectID"}}`, encodeURIComponent(String(projectID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("LoaderoAuth")
					: configuration.apiKey;
                localVarHeaderParameter["LoaderoAuth"] = localVarApiKeyValue;
            }

            if (describe !== undefined) {
                localVarQueryParameter['describe'] = describe;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = (created as any).toISOString();
            }

            if (updated !== undefined) {
                localVarQueryParameter['updated'] = (updated as any).toISOString();
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (scriptFileId !== undefined) {
                localVarQueryParameter['script_file_id'] = scriptFileId;
            }

            if (startInterval !== undefined) {
                localVarQueryParameter['start_interval'] = startInterval;
            }

            if (participantTimeout !== undefined) {
                localVarQueryParameter['participant_timeout'] = participantTimeout;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (incrementStrategy !== undefined) {
                localVarQueryParameter['increment_strategy'] = incrementStrategy;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (groupCount !== undefined) {
                localVarQueryParameter['group_count'] = groupCount;
            }

            if (participantCount !== undefined) {
                localVarQueryParameter['participant_count'] = participantCount;
            }

            if (script !== undefined) {
                localVarQueryParameter['script'] = script;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestApi - functional programming interface
 * @export
 */
export const TestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint creates new test with given data.
         * @summary Create new test
         * @param {string} name 
         * @param {number} startInterval 
         * @param {number} participantTimeout 
         * @param {string} mode 
         * @param {string} incrementStrategy 
         * @param {string} script 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {number} [id] readonly: true
         * @param {Date} [created] readonly: true
         * @param {Date} [updated] readonly: true
         * @param {number} [projectId] readonly: true
         * @param {number} [scriptFileId] readonly: true
         * @param {boolean} [deleted] readonly: true
         * @param {number} [groupCount] readonly: true
         * @param {number} [participantCount] readonly: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTest(name: string, startInterval: number, participantTimeout: number, mode: string, incrementStrategy: string, script: string, projectID: number, describe?: string, id?: number, created?: Date, updated?: Date, projectId?: number, scriptFileId?: number, deleted?: boolean, groupCount?: number, participantCount?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Test> {
            const localVarFetchArgs = TestApiFetchParamCreator(configuration).createTest(name, startInterval, participantTimeout, mode, incrementStrategy, script, projectID, describe, id, created, updated, projectId, scriptFileId, deleted, groupCount, participantCount, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint deletes test. Project and test must be previously created
         * @summary Delete existing test
         * @param {number} testID 
         * @param {number} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTest(testID: number, projectID: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TestApiFetchParamCreator(configuration).deleteTest(testID, projectID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint duplicates given test. If no copy name is provided an \"Copy of\" prefix will be applied to the test name. Project and test must be previously created.
         * @summary Duplicate existing test
         * @param {number} testID 
         * @param {number} projectID 
         * @param {TestIDCopyBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateTest(testID: number, projectID: number, body?: TestIDCopyBody, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Test> {
            const localVarFetchArgs = TestApiFetchParamCreator(configuration).duplicateTest(testID, projectID, body, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves all test info. Project must be previously created
         * @summary Get all existing tests for project
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterName] 
         * @param {string} [filterTestMode] 
         * @param {string} [filterIncrementStrategy] 
         * @param {string} [filterStartIntervalFrom] 
         * @param {string} [filterStartIntervalTo] 
         * @param {string} [filterParticipantTimeoutFrom] 
         * @param {string} [filterParticipantTimeoutTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTests(projectID: number, limit?: number, offset?: number, describe?: string, filterName?: string, filterTestMode?: string, filterIncrementStrategy?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
            const localVarFetchArgs = TestApiFetchParamCreator(configuration).readAllTests(projectID, limit, offset, describe, filterName, filterTestMode, filterIncrementStrategy, filterStartIntervalFrom, filterStartIntervalTo, filterParticipantTimeoutFrom, filterParticipantTimeoutTo, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint retrieves test info. Project and test must be previously created
         * @summary Read test info
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTest(testID: number, projectID: number, describe?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Test> {
            const localVarFetchArgs = TestApiFetchParamCreator(configuration).readTest(testID, projectID, describe, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint updates test with given properties. Project and test must be previously created
         * @summary Update existing test
         * @param {string} name 
         * @param {number} startInterval 
         * @param {number} participantTimeout 
         * @param {string} mode 
         * @param {string} incrementStrategy 
         * @param {string} script 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {number} [id] readonly: true
         * @param {Date} [created] readonly: true
         * @param {Date} [updated] readonly: true
         * @param {number} [projectId] readonly: true
         * @param {number} [scriptFileId] readonly: true
         * @param {boolean} [deleted] readonly: true
         * @param {number} [groupCount] readonly: true
         * @param {number} [participantCount] readonly: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTest(name: string, startInterval: number, participantTimeout: number, mode: string, incrementStrategy: string, script: string, testID: number, projectID: number, describe?: string, id?: number, created?: Date, updated?: Date, projectId?: number, scriptFileId?: number, deleted?: boolean, groupCount?: number, participantCount?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Test> {
            const localVarFetchArgs = TestApiFetchParamCreator(configuration).updateTest(name, startInterval, participantTimeout, mode, incrementStrategy, script, testID, projectID, describe, id, created, updated, projectId, scriptFileId, deleted, groupCount, participantCount, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TestApi - factory interface
 * @export
 */
export const TestApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This endpoint creates new test with given data.
         * @summary Create new test
         * @param {string} name 
         * @param {number} startInterval 
         * @param {number} participantTimeout 
         * @param {string} mode 
         * @param {string} incrementStrategy 
         * @param {string} script 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {number} [id] readonly: true
         * @param {Date} [created] readonly: true
         * @param {Date} [updated] readonly: true
         * @param {number} [projectId] readonly: true
         * @param {number} [scriptFileId] readonly: true
         * @param {boolean} [deleted] readonly: true
         * @param {number} [groupCount] readonly: true
         * @param {number} [participantCount] readonly: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTest(name: string, startInterval: number, participantTimeout: number, mode: string, incrementStrategy: string, script: string, projectID: number, describe?: string, id?: number, created?: Date, updated?: Date, projectId?: number, scriptFileId?: number, deleted?: boolean, groupCount?: number, participantCount?: number, options?: any) {
            return TestApiFp(configuration).createTest(name, startInterval, participantTimeout, mode, incrementStrategy, script, projectID, describe, id, created, updated, projectId, scriptFileId, deleted, groupCount, participantCount, options)(fetch, basePath);
        },
        /**
         * This endpoint deletes test. Project and test must be previously created
         * @summary Delete existing test
         * @param {number} testID 
         * @param {number} projectID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTest(testID: number, projectID: number, options?: any) {
            return TestApiFp(configuration).deleteTest(testID, projectID, options)(fetch, basePath);
        },
        /**
         * This endpoint duplicates given test. If no copy name is provided an \"Copy of\" prefix will be applied to the test name. Project and test must be previously created.
         * @summary Duplicate existing test
         * @param {number} testID 
         * @param {number} projectID 
         * @param {TestIDCopyBody} [body] 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateTest(testID: number, projectID: number, body?: TestIDCopyBody, describe?: string, options?: any) {
            return TestApiFp(configuration).duplicateTest(testID, projectID, body, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves all test info. Project must be previously created
         * @summary Get all existing tests for project
         * @param {number} projectID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [describe] 
         * @param {string} [filterName] 
         * @param {string} [filterTestMode] 
         * @param {string} [filterIncrementStrategy] 
         * @param {string} [filterStartIntervalFrom] 
         * @param {string} [filterStartIntervalTo] 
         * @param {string} [filterParticipantTimeoutFrom] 
         * @param {string} [filterParticipantTimeoutTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readAllTests(projectID: number, limit?: number, offset?: number, describe?: string, filterName?: string, filterTestMode?: string, filterIncrementStrategy?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, options?: any) {
            return TestApiFp(configuration).readAllTests(projectID, limit, offset, describe, filterName, filterTestMode, filterIncrementStrategy, filterStartIntervalFrom, filterStartIntervalTo, filterParticipantTimeoutFrom, filterParticipantTimeoutTo, options)(fetch, basePath);
        },
        /**
         * This endpoint retrieves test info. Project and test must be previously created
         * @summary Read test info
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readTest(testID: number, projectID: number, describe?: string, options?: any) {
            return TestApiFp(configuration).readTest(testID, projectID, describe, options)(fetch, basePath);
        },
        /**
         * This endpoint updates test with given properties. Project and test must be previously created
         * @summary Update existing test
         * @param {string} name 
         * @param {number} startInterval 
         * @param {number} participantTimeout 
         * @param {string} mode 
         * @param {string} incrementStrategy 
         * @param {string} script 
         * @param {number} testID 
         * @param {number} projectID 
         * @param {string} [describe] 
         * @param {number} [id] readonly: true
         * @param {Date} [created] readonly: true
         * @param {Date} [updated] readonly: true
         * @param {number} [projectId] readonly: true
         * @param {number} [scriptFileId] readonly: true
         * @param {boolean} [deleted] readonly: true
         * @param {number} [groupCount] readonly: true
         * @param {number} [participantCount] readonly: true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTest(name: string, startInterval: number, participantTimeout: number, mode: string, incrementStrategy: string, script: string, testID: number, projectID: number, describe?: string, id?: number, created?: Date, updated?: Date, projectId?: number, scriptFileId?: number, deleted?: boolean, groupCount?: number, participantCount?: number, options?: any) {
            return TestApiFp(configuration).updateTest(name, startInterval, participantTimeout, mode, incrementStrategy, script, testID, projectID, describe, id, created, updated, projectId, scriptFileId, deleted, groupCount, participantCount, options)(fetch, basePath);
        },
    };
};

/**
 * TestApi - object-oriented interface
 * @export
 * @class TestApi
 * @extends {BaseAPI}
 */
export class TestApi extends BaseAPI {
    /**
     * This endpoint creates new test with given data.
     * @summary Create new test
     * @param {string} name 
     * @param {number} startInterval 
     * @param {number} participantTimeout 
     * @param {string} mode 
     * @param {string} incrementStrategy 
     * @param {string} script 
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {number} [id] readonly: true
     * @param {Date} [created] readonly: true
     * @param {Date} [updated] readonly: true
     * @param {number} [projectId] readonly: true
     * @param {number} [scriptFileId] readonly: true
     * @param {boolean} [deleted] readonly: true
     * @param {number} [groupCount] readonly: true
     * @param {number} [participantCount] readonly: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public createTest(name: string, startInterval: number, participantTimeout: number, mode: string, incrementStrategy: string, script: string, projectID: number, describe?: string, id?: number, created?: Date, updated?: Date, projectId?: number, scriptFileId?: number, deleted?: boolean, groupCount?: number, participantCount?: number, options?: any) {
        return TestApiFp(this.configuration).createTest(name, startInterval, participantTimeout, mode, incrementStrategy, script, projectID, describe, id, created, updated, projectId, scriptFileId, deleted, groupCount, participantCount, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint deletes test. Project and test must be previously created
     * @summary Delete existing test
     * @param {number} testID 
     * @param {number} projectID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public deleteTest(testID: number, projectID: number, options?: any) {
        return TestApiFp(this.configuration).deleteTest(testID, projectID, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint duplicates given test. If no copy name is provided an \"Copy of\" prefix will be applied to the test name. Project and test must be previously created.
     * @summary Duplicate existing test
     * @param {number} testID 
     * @param {number} projectID 
     * @param {TestIDCopyBody} [body] 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public duplicateTest(testID: number, projectID: number, body?: TestIDCopyBody, describe?: string, options?: any) {
        return TestApiFp(this.configuration).duplicateTest(testID, projectID, body, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves all test info. Project must be previously created
     * @summary Get all existing tests for project
     * @param {number} projectID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [describe] 
     * @param {string} [filterName] 
     * @param {string} [filterTestMode] 
     * @param {string} [filterIncrementStrategy] 
     * @param {string} [filterStartIntervalFrom] 
     * @param {string} [filterStartIntervalTo] 
     * @param {string} [filterParticipantTimeoutFrom] 
     * @param {string} [filterParticipantTimeoutTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public readAllTests(projectID: number, limit?: number, offset?: number, describe?: string, filterName?: string, filterTestMode?: string, filterIncrementStrategy?: string, filterStartIntervalFrom?: string, filterStartIntervalTo?: string, filterParticipantTimeoutFrom?: string, filterParticipantTimeoutTo?: string, options?: any) {
        return TestApiFp(this.configuration).readAllTests(projectID, limit, offset, describe, filterName, filterTestMode, filterIncrementStrategy, filterStartIntervalFrom, filterStartIntervalTo, filterParticipantTimeoutFrom, filterParticipantTimeoutTo, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint retrieves test info. Project and test must be previously created
     * @summary Read test info
     * @param {number} testID 
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public readTest(testID: number, projectID: number, describe?: string, options?: any) {
        return TestApiFp(this.configuration).readTest(testID, projectID, describe, options)(this.fetch, this.basePath);
    }

    /**
     * This endpoint updates test with given properties. Project and test must be previously created
     * @summary Update existing test
     * @param {string} name 
     * @param {number} startInterval 
     * @param {number} participantTimeout 
     * @param {string} mode 
     * @param {string} incrementStrategy 
     * @param {string} script 
     * @param {number} testID 
     * @param {number} projectID 
     * @param {string} [describe] 
     * @param {number} [id] readonly: true
     * @param {Date} [created] readonly: true
     * @param {Date} [updated] readonly: true
     * @param {number} [projectId] readonly: true
     * @param {number} [scriptFileId] readonly: true
     * @param {boolean} [deleted] readonly: true
     * @param {number} [groupCount] readonly: true
     * @param {number} [participantCount] readonly: true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestApi
     */
    public updateTest(name: string, startInterval: number, participantTimeout: number, mode: string, incrementStrategy: string, script: string, testID: number, projectID: number, describe?: string, id?: number, created?: Date, updated?: Date, projectId?: number, scriptFileId?: number, deleted?: boolean, groupCount?: number, participantCount?: number, options?: any) {
        return TestApiFp(this.configuration).updateTest(name, startInterval, participantTimeout, mode, incrementStrategy, script, testID, projectID, describe, id, created, updated, projectId, scriptFileId, deleted, groupCount, participantCount, options)(this.fetch, this.basePath);
    }

}
